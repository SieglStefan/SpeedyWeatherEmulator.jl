var documenterSearchIndex = {"docs":
[{"location":"functions_index/#Functions-and-Types-index","page":"Functions & Types index","title":"Functions & Types index","text":"","category":"section"},{"location":"functions_index/#Core","page":"Functions & Types index","title":"Core","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Defines the fundamental data structure (SimPara) describing  how simulation data is parameterized. Further it contains helpful utility functions (calc_n_coeff, is_coeff_zero).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.SimPara","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimPara","text":"SimPara{F}\n\nContainer for core simulation parameters that define SpeedyWeather.jl data generation,      resulting data shape and storage name.\n\nFields\n\ntrunc::Int: Spectral truncation of the barotropic model (e.g. 5 for T5).\nn_data::Int: Number of stored data time steps after spin-up.\nn_ic::Int: Number of simulated initial conditions (independent runs).\nn_spinup::Int: Number of spin-up steps discarded before sampling.\nt_step::Float32: Physical time step length.\ninitial_cond::F: Optional generator for initial conditions; if nothing, random ICs are used.\nid_key::String: Additional identifier to disambiguate saved datasets with identical trunc, n_data and n_ic.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.SimPara-Tuple{}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimPara","text":"SimPara(;   trunc,\n            n_data,\n            n_ic,\n            n_spinup = 9,\n            t_step = 1.0,\n            initial_cond = nothing,\n            id_key = \"\")\n\nConvenience constructor for SimPara.\n\nArguments\n\ntrunc::Int: Spectral truncation of the barotropic model (e.g. 5 for T5).\nn_data::Int: Number of stored data time steps after spin-up.\nn_ic::Int: Number of simulated initial conditions (independent runs).\nn_spinup::Int = 9: Number of spin-up steps discarded before sampling (Default data sampling begins at t=10h).\nt_step::Real = 1.0: Physical time step length.\ninitial_cond = nothing: Optional generator for initial conditions; if nothing, random ICs are used. Can also be a Function or any callable object.\nid_key::String = \"\": Additional identifier to disambiguate saved datasets with identical (trunc, n_data, n_ic).\n\nReturns\n\n::SimPara: Container for simulation parameters that define the simulation and data storage.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"_test\")\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.calc_n_coeff-Tuple{}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.calc_n_coeff","text":"calc_n_coeff(; trunc::Int)\n\nCalculate the number of complex spectral coefficients for a given spectral truncation.\n\nArguments\n\ntrunc::Int: Spectral truncation of the barotropic model (e.g. 5 for T5).\n\nReturns\n\nn_coeff::Int: Number of complex spectral coefficients (without splitting into real/imag parts).\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#IO","page":"Functions & Types index","title":"IO","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Provides functions for handling data. Including creating data paths (data_path), deleting data (delete_data), and saving/loading data (save_data, load_data) for specific types.","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.data_path-Tuple{SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.data_path","text":"data_path(sim_para::SimPara; type::String)\n\nCreates the folder or file path for storing data associated with sim_para.\n\nArguments\n\nsim_para::SimPara: Simulation parameters (used to build unique name).\ntype::String: Data type; \"raw_data\", \"sim_data\", \"emulator\" or \"losses\".\npath::String = \"\": Optional absolute path for data storage.     If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\n::String: Absolute normalized path to the storage location.\n\nNaming Convention\n\nFor raw data: /data/raw_data/T<trunc>_ndata<n_data>_IC<n_ic>_ID<id_key>/\nFor all other types: /data/<type>/<type>_T<trunc>_ndata<n_data>_IC<n_ic>_ID<id_key>.jld2\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"demo\")\ndata_path(sim_para; type=\"sim_data\")\n# → \".../data/sim_data/sim_data_T5_ndata50_IC200_IDdemo.jld2\"\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.delete_data-Tuple{SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.delete_data","text":"delete_data(sim_para::SimPara; type::String, overwrite::Bool=false)\n\nDelete existing data of type \"raw_data\", \"sim_data\", \"emulator\" or \"losses\"\n\nDescription\n\nChecks whether the path already exists.\nIf overwrite=true: deletes existing content and creates a new folder if type = \"raw_data\".\nIf overwrite=false: keeps existing data untouched and sets cancel_sim=true to cancel current process.\n\nArguments\n\nsim_para::SimPara: Simulation parameters (used for identifying data).\ntype::String: Data type; \"raw_data\", \"sim_data\", \"emulator\", \"losses\".\noverwrite::Bool = false: Control overwrite behavior.\npath::String = \"\": Optional absolute path for data storage.     If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\npath::String: Target folder/file path.\ncancel_sim::Bool: True if the current process must be stopped because data is not allowed to be overwritten.\n\nNotes\n\nFor \"raw_data\", creates a directory tree.\nFor other types, returns the target .jld2 path (no folder created).\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"test\")\ndelete_data(sim_para; type=\"sim_data\")\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.load_data-Tuple{SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.load_data","text":"load_data(sim_para::SimPara; type::String)\n\nLoad previously saved data of a given type using the defining simulation parameters.\n\nArguments\n\nsim_para::SimPara: Simulation parameters; determines the folder/file name.\ntype::String: Dataset type, e.g. \"sim_data\", \"emulator\", \"losses\".\npath::String = \"\": Optional absolute path for data loading.   If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\n::Union{SimData, Emulator, Losses}: The saved object stored in the JLD2 file under the key \"data\".   (For example a SimData, Emulator, or Losses object.)\n\nNotes\n\nload_data is intended for JLD2-based single-file storage types.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200)\nsim_data_loaded = load_data(sim_para; type=\"sim_data\")\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.save_data-Tuple{Union{Losses, Emulator, SimData}}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.save_data","text":"save_data(data::Union{SimData, Emulator, Losses}; overwrite::Bool=false)\n\nSave simulation- or training-related data (SimData, Emulator, Losses) using JLD2.\n\nDescription\n\nBuilds a consistent file/folder path from the associated SimPara via data_path for saving data.\nPrevents overwriting unless overwrite=true.\nUses JLD2 to serialize the given data.\n\nArguments\n\ndata::Union{SimData, Emulator, Losses}: The container to save.   Must have a field sim_para::SimPara.\noverwrite::Bool = false: If true, existing file/folder is deleted before writing.\npath::String = \"\": Optional absolute path for data saving.   If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\nnothing: Data is written to the file system.\n\nNotes\n\nFor raw_data: Creates a directory tree with subfolders run_0001, run_0002, ….\nFor all other types: Saves to a single .jld2 file.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"demo\")\nsim_data = SimData(sim_para)\nsave_data(sim_data; type=\"sim_data\", overwrite=true)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#Data","page":"Functions & Types index","title":"Data","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Handles data generation and preparation. This includes creating raw simulation data with SpeedyWeather.jl (generate_raw_data), wrapping it into structured containers (SimData), and formatting it into train/validation/test sets (DataPairs, FormattedData).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.generate_raw_data-Tuple{SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.generate_raw_data","text":"generate_raw_data(sim_para::SimPara; overwrite::Bool=false, path::String=\"\")\n\nGenerate raw vorticity data with SpeedyWeather.jl based on the given simulation parameters.\n\nDescription\n\nPrepares a raw-data folder using prepare_folder.\nRuns the barotropic model with spectral truncation sim_para.trunc and time step sim_para.t_step.\nFor each initial condition (IC), creates a new run subfolder and stores the simulated vorticity.\nIf overwrite=false and data already exist, generation is canceled.\n\nArguments\n\nsim_para::SimPara: Container for parameters that define the simulation and data storage.\noverwrite::Bool = false: If true, delete existing data and regenerate.     If false, aborts safely when data already exist.\npath::String = \"\": Optional absolute path for data storage.     If left empty, the function defaults to the package's internal data/<type> folder.\n\nReturns\n\n::Bool: Returns a boolean value that indicates if the data was generated successfully.\n\nNotes\n\nSpin-up steps (n_spinup) are run but not stored in later SimData.\nIf sim_para.initial_cond is not nothing, this function applies the given IC via set!(sim, vor=…).\nSometimes overwriting raw_data files is not possible because the folders are open/busy.   Data Generation is then canceled.\nOnly prognostic variables are stored.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"123\")\ngenerate_raw_data(sim_para; overwrite=true)\n# → creates data/raw_data/raw_data_T5_ndata50_IC200_ID123/run_0001/output.jld2, ..., run_0200/output.jld2\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.SimData","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimData","text":"SimData(sim_para::SimPara, path::String=\"\")\n\nConstruct a SimData container by loading previously generated raw data and extracting the spectral vorticity coefficients time series into a consistent tensor layout.\n\nThis constructor:\n\ninfers (n_coeff, n_data, n_ic) from sim_para,\nallocates the target array data::Array{Float32,3} with shape (2 * n_coeff, n_data, n_ic),\niterates over runs ic = 1:n_ic, loads output.jld2, and reads output_vector,\nfor each stored step step ∈ {n_spinup+1, …, n_spinup + n_data}:\nextracts the spectral vorticity vor,\nwrites real(vor) to rows 1:n_coeff and imag(vor) to rows n_coeff+1:2n_coeff,\nstores at time index step + 1 - n_spinup.\n\nArguments\n\nsim_para::SimPara{F}: Container for parameters that define the simulation and data storage;    must match the generated raw data on disk.\npath::String = \"\": Optional absolute path of storaged raw_data.     If left empty, the function defaults to the package's internal data/<type> folder.\n\nReturns\n\n::SimData{F, Array{Float32,3}}: Container holding simulation data and corresponding sim. parameters.\n\nPreconditions\n\nExpects raw data in data_path(sim_para; type=\"raw_data\") with per-run subfolders   run_0001, run_0002, … each containing output.jld2 with an output_vector.\nRaw data should be created beforehand via generate_raw_data(sim_para; overwrite=false).\n\nNotes\n\nThe leading factor 2 in the first dimension stacks real and imaginary parts.\nThe time indexing uses step - n_spinup to map stored steps to 1:n_data.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200)\n# after generate_raw_data(sim_para) has been called:\nsim_data = SimData(sim_para)\n# inspect shapes\nsize(sim_data.data)  # (2*n_coeff, n_data, n_ic)\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.SimData-2","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimData","text":"SimData{F, A<:AbstractArray{Float32, 3}}\n\nContainer for SpeedyWeather.jl vorticity data together with the simulation parameters.\n\nFields\n\nsim_para::SimPara{F}: Container for parameters that define the simulation and data storage.\ndata::A: Vorticity tensor with shape (2 * n_coeff, n_data, n_ic)       where n_coeff = calc_n_coeff(sim_para.trunc).        The first n_coeff rows store the real parts,        the next n_coeff rows the imaginary parts of the complex spectral coefficients.\n\nNotes\n\nThe layout is column-major and optimized for contiguous slicing over time and ICs.\nDimensions are inferred from sim_para and remain consistent across the pipeline.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.DataPairs","page":"Functions & Types index","title":"SpeedyWeatherEmulator.DataPairs","text":"DataPairs{A<:AbstractArray{Float32, 2}}\n\nContainer for paired data samples (x,y) = (vor(t), vor(t+Δt)), already split into training, validation and test sets.\n\nFields\n\nx_train::A: Training inputs vor(t).\ny_train::A: Training targets vor(t+Δt).\nx_valid::A: Validation inputs vor(t).\ny_valid::A: Validation targets vor(t+Δt).\nx_test::A: Test inputs vor(t).\ny_test::A: Test targets vor(t+Δt).\n\nNotes\n\nAll matrices have the same row dimension = 2 * n_coeff.\nColumns index over independent time-pairs and ICs.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.FormattedData","page":"Functions & Types index","title":"SpeedyWeatherEmulator.FormattedData","text":"FormattedData{F, A<:AbstractArray{Float32, 2}}\n\nContainer for formatted data, i.e. paired vorticity samples (x,y) = (vor(t), vor(t+Δt)).\n\nFields\n\nsim_para::SimPara{F}: Container for parameters that define the simulation and data storage.\ndata_pairs::DataPairs{A}: The split and paired data.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.FormattedData-Tuple{SimData}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.FormattedData","text":"FormattedData(  sim_data::SimData; \n                splits::NamedTuple{(:train, :valid, :test),<:Tuple{Vararg{Real,3}}} = \n                    (train=0.7, valid=0.15, test=0.15))\n\nConstruct FormattedData directly from SimData by pairing consecutive time steps     and splitting them into train/validation/test sets.\n\nDescription\n\nBuilds (x,y) pairs as\nx = vor(t) = spectral vorticity state at time t,\ny = vor(t+Δt) at the next time step.\nReshapes all ICs and times into column vectors.\nSplits the resulting pairs according to the fractions in splits.\n\nArguments\n\nsim_data::SimData: Container holding simulation data and corresponding sim. parameters.\nsplits::NamedTuple{(:train, :valid, :test),<:Tuple{Vararg{Real,3}}}: Fractions for train-, valid- and test-set.     Default = (0.7, 0.15, 0.15).\n\nReturns\n\n::FormattedData: Container holding formatted (paired) simulation data and corresponding sim. parameters.\n\nNotes\n\nThe number of total pairs is (n_data - 1) * n_ic.\nSplits are normalized so that train + valid + test = 1.\n\nExamples\n\nfd = FormattedData(sim_data; splits=(train=0.7, valid=0.2, test=0.1))\nsize(fd.data_pairs.x_train)  # (2*n_coeff, n_train)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#Emulator","page":"Functions & Types index","title":"Emulator","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Handles emulator definition, normalization, training, and evaluation. This includes Z-score normalization utilities (ZscorePara, zscore, inv_zscore), core emulator types (NeuralNetwork, Emulator, Losses), training workflow (train_emulator), and evaluation against SpeedyWeather.jl reference data (compare_emulator).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.ZscorePara","page":"Functions & Types index","title":"SpeedyWeatherEmulator.ZscorePara","text":"ZscorePara{F<:AbstractVector{Float32}}\n\nContainer for the parameters of a Z-score transformation.\n\nFields\n\nμ::F: Mean for each coefficient across samples.\nσ::F: Std for each coefficient across samples.\n\nNotes\n\nTypically computed from the training set only to avoid data leakage.\nFor each coefficient indexed i: zi = (xi - μi) / σi\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.inv_zscore-Tuple{AbstractArray{Float32}, ZscorePara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.inv_zscore","text":"inv_zscore(x::AbstractArray{Float32}, stats::ZscorePara{<:AbstractVector{Float32}})\n\nInverse Z-score transformation (restore original scale).\n\nArguments\n\nx::AbstractArray{Float32}: Z-score normalized data.\nstats::ZscorePara{<:AbstractVector{Float32}}: Parameters with mean μ and std σ.\n\nReturns\n\n::typeof(x): Data rescaled back to the original distribution.\n\nExamples\n\nstats = ZscorePara([0.0f0, 1.0f0], [1.0f0, 2.0f0])\nz = Float32[0 -0.5; 1 0.5]\nx = inv_zscore(z, stats)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.zscore-Tuple{AbstractArray{Float32}, ZscorePara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.zscore","text":"zscore(x::AbstractArray{Float32}, stats::ZscorePara{<:AbstractVector{Float32}})\n\nApply a Z-score transformation to data x using the parameters in stats.\n\nArguments\n\nx::AbstractArray{Float32}: Input data (rows = coefficients, columns = samples).\nstats::ZscorePara{<:AbstractVector{Float32}}: Parameters with mean μ and std σ.\n\nReturns\n\n::typeof(x): Z-score normalized data.\n\nNotes\n\nEach coefficient is transformed independently.\nA small eps(Float32) is added to σ to avoid division by zero.\n\nExamples\n\nstats = ZscorePara([0.0f0, 1.0f0], [1.0f0, 2.0f0])\nx = Float32[0 2; 1 3]\nz = zscore(x, stats)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.Emulator","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Emulator","text":"Emulator{A<:AbstractVector{Float32}}\n\nContainer for a trained (or in-progress) neural network emulator.\n\nFields\n\nsim_para::SimPara: Simulation parameters of the dataset used for training, validation and testing.\nchain::Flux.Chain: Neural network architecture and weights.\nzscore_para::ZscorePara{A}: Normalization parameters (mean/std of training set).\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.Emulator-Tuple{NeuralNetwork, ZscorePara, SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Emulator","text":"Emulator(nn::NeuralNetwork, zscore_para::ZscorePara, sim_para::SimPara)\n\nConstructor for an Emulator. Builds a feed-forward network with ReLU activations according to the given NeuralNetwork specs.\n\nArguments\n\nnn::NeuralNetwork: Parameters of the architecture (layer sizes).\nzscore_para::ZscorePara: Normalization parameters of the training data.\nsim_para::SimPara: Simulation parameters used for generating the training data.\n\nReturns\n\n::Emulator: A wrapped Flux model with normalization metadata.\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.Emulator-Tuple{VecOrMat{Float32}}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Emulator","text":"(m::Emulator)(x::Union{Vector{Float32}, Matrix{Float32}})\n\nConvenience call overload. Apply the trained emulator to spectral coefficients at time t to predict coefficients at t + Δt.\n\nArguments\n\nx::Vector{Float32}: Spectral coefficients of vorticity at time t (size = 2 * n_coeff).\nx::Matrix{Float32}: Multiple states, each column a spectral coefficients vector at time t (size = (2 * n_coeff, N)).\n\nReturns\n\n::Vector{Float32}: Emulator prediction for a single state at t + Δt (same size as input vector).\n::Matrix{Float32}: Emulator predictions for multiple states, one prediction per column (same shape as input matrix).\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.Losses","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Losses","text":"Losses\n\nContainer for logging training and validation losses and training time.\n\nFields\n\nsim_para::SimPara: Simulation parameters of the dataset used.\ntrain::Vector{Float32}: Training loss per batch.\nvalid::Vector{Float32}: Validation loss per batch.\nbpe_train::Int64: Batches per epoch (training set).\nbpe_valid::Int64: Batches per epoch (validation set).\ntraining_time: Time needed for training the model in seconds.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.Losses-Tuple{SimPara, Int64, Int64}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Losses","text":"Losses(sim_para::SimPara, bpe_train::Int64, bpe_valid::Int64)\n\nConstructor for an empty Losses container.\n\nArguments\n\nsim_para::SimPara: Simulation parameters of the dataset used.\nbpe_train::Int64: Batches per epoch (training set).\nbpe_valid::Int64: Batches per epoch (validation set).\n\nReturns\n\n::Losses: Initialized container with empty loss vectors and training_time = 0.0.\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.NeuralNetwork","page":"Functions & Types index","title":"SpeedyWeatherEmulator.NeuralNetwork","text":"NeuralNetwork\n\nContainer for the layer dimensions of a neural network.\n\nFields\n\nio_dim::Int: Dimension of the input and output layer (e.g. number of spectral coefficients).\nhidden_dim::Int: Dimension of each hidden layer.\nn_hidden::Int: Number of hidden layers.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.NeuralNetwork-Tuple{}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.NeuralNetwork","text":"NeuralNetwork(; io_dim::Int=54, hidden_dim::Int=1024, n_hidden::Int=1)\n\nConvenience constructor for NeuralNetwork.\n\nArguments\n\nio_dim::Int: Dimension of the input and output layer (e.g. number of spectral coefficients).\nhidden_dim::Int: Dimension of each hidden layer.\nn_hidden::Int: Number of hidden layers.\n\nReturns\n\n::NeuralNetwork: Parameter container.\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.compare_emulator-Tuple{Emulator}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.compare_emulator","text":"compare_emulator(em::Emulator; \n                 x_test::Matrix{Float32},\n                 y_test::Matrix{Float32},\n                 n_it::Int64=1,\n                 output::Bool=false,\n                 all_coeff::Bool=false)\n\nCompare emulator predictions against SpeedyWeather.jl reference data.\n\nDescription\n\nApplies the emulator em to test inputs x_test and compares results to y_test for n_it timesteps.\nComputes mean relative error per spectral coefficient:    relerri = |ŷi - yi| / (|y_i| + ε) * 100.\nPrints mean relative error (all coefficients averaged) and maximum mean relative error.\nOptionally prints coefficient-wise relative errors.\n\nArguments\n\nem::Emulator: Trained emulator to evaluate.\nx_test::Matrix{Float32}: Test inputs (vorticity coefficients at t) of form (2 * n_coeff, N).\ny_test::Matrix{Float32}: Reference outputs from SpeedyWeather.jl (at t+nit*Δt) of form (2 * ncoeff, N).\nn_it::Int64: Number of timesteps compared.\noutput::Bool=false: If true, print errors to STDOUT.\nall_coeff::Bool=false: If true, print relative error for each coefficient.\nid_em::Bool=false: The identiy emulator is used (em(vor(t)) = vor(t))\n\nReturns\n\nmean_mean_rel::Float32: The mean (all spectral coeff.) mean (all possible datapairs) relative error for n_it timesteps.\n\nNotes\n\nThe larger n_it, the fewer data pairs are available for comparison. For example:   n_data=4 and n_it=2 leads to data pairs 1-2-3 and 2-3-4.\nSome coefficients in SpeedyWeather.jl are structurally zero → flagged in output.\nErrors are reported in percent [%].\n\nExamples\n\nemu, losses = train_emulator(nn, fd)\ncompare_emulator(emu; \n    x_test=fd.data_pairs.x_test,\n    y_test=fd.data_pairs.y_test,\n    all_coeff=true)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.train_emulator-Tuple{NeuralNetwork, FormattedData}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.train_emulator","text":"train_emulator(nn::NeuralNetwork, fd::FormattedData; sim_para::SimPara=fd.sim_para, \n               batchsize::Int=32, n_epochs::Int=300, η0::Real=0.001)\n\nTrain an emulator (neural network) with the given architecture and data.\n\nDescription\n\nComputes Z-score parameters from the training set.\nConstructs an Emulator with the given NeuralNetwork.\nApplies Z-score normalization to training and validation pairs.\nTrains the network using Adam with initial learning rate η0.\nHalves the learning rate every 30 epochs.\nLogs training and validation losses.\nCalls compare_emulator on the test set after training.\n\nArguments\n\nnn::NeuralNetwork: Defines the structure (layer sizes) of the neural network.\nfd::FormattedData: Formatted dataset with train/valid/test splits of size (2*n_coeff, N).\nsim_para::SimPara=fd.sim_para: Optional different simulation parameters for better saving.\nbatchsize::Int=32: Training batch size.\nn_epochs::Int=300: Number of training epochs.\nη0::Real=0.001: Initial learning rate.\n\nReturns\n\nem::Emulator: Trained emulator model (Flux chain + normalization).\nlosses::Losses: Recorded training/validation losses and batches per epoch.\n\nNotes\n\nTest set evaluation is not part of the training loop; only compare_emulator is called at the end.\nNormalization statistics are always computed from the training set to avoid leakage.\n\nExamples\n\nnn = NeuralNetwork(io_dim=54, hidden_dim=128, n_hidden=2)\nfd = FormattedData(sim_data; splits=(train=0.7, valid=0.2, test=0.1))\nem, losses = train_emulator(nn, fd; batchsize=64, n_epochs=100, η0=0.0005)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#Evaluation","page":"Functions & Types index","title":"Evaluation","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Handles evaluation and visualization of emulator and simulation output. This includes plotting forecast stability for SpeedyWeather.jl runs (plot_forecast_test), plotting loss plots (plot_losses), and reconstructing vorticity fields from spectral coefficients as heatmaps (plot_heatmap).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.plot_losses-Tuple{Losses}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.plot_losses","text":"plot_losses(losses::Losses)\n\nPlot training and validation losses stored in a Losses container.\n\nDescription\n\nPlots training loss per batch (log-log scale).\nAdds epoch-averaged training and validation loss curves.\nReturns a Plots.Plot object for further customization or saving.\n\nArguments\n\nlosses::Losses: Container with training/validation loss history and number of batches per epoch.\ntitle::String=\"Losses of the emulator\": Optional argument for different plot titles (e.g. differen simulation parameters).\n\nReturns\n\np::Plots.Plot: Combined plot of training and validation losses.\n\nNotes\n\nTraining batches per epoch = losses.bpe_train.\nValidation batches per epoch = losses.bpe_valid.\nNumber of epochs is inferred as length(losses.train) / bpe_train.\n\nExamples\n\nemu, losses = train_emulator(nn, fd)\np = plot_losses(losses)\ndisplay(p)  \n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.plot_heatmap-Tuple{Vector{Float32}}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.plot_heatmap","text":"plot_heatmap(vec::Vector{Float32}; trunc::Int64, title::String=\"\")\n\nPlot a heatmap of a vorticity field reconstructed from a spectral coefficient vector.\n\nDescription\n\nConverts spectral coefficients in vector form into a LowerTriangularMatrix.\nTransforms this into a grid suitable for plotting.\nDisplays the grid as a heatmap using CairoMakie.\n\nArguments\n\nvec::Vector{Float32}: Spectral coefficient vector (real/imag stacked).\ntrunc::Int64: Spectral truncation of the model (e.g. 5 for T5).\ntitle::String=\"Vorticity Heatmap\": Optional argument for different plot titles (e.g. differen simulation parameters).\nrange::Tuple{Float64,Float64}: Defines the color range of the heatmap plot.\n\nReturns\n\n::CairoMakie.Plot: Heatmap figure object.\n\nExamples\n\nvec = rand(Float32, 54)   # random spectral coeffs for trunc=5\nfig = plot_heatmap(vec; trunc=5, title=\"Vorticity field\")\ndisplay(fig)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.vec_to_ltm-Tuple{Vector{Float32}, Int64}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.vec_to_ltm","text":"vec_to_ltm(vec::Vector{Float32}, trunc::Int64)\n\nConvert a spectral coefficient vector into a LowerTriangularMatrix representation.\n\nDescription\n\nInterprets the coefficient vector as complex spectral coefficients.\nPlaces them into a triangular matrix layout consistent with SpeedyWeather.jl.\n\nArguments\n\nvec::Vector{Float32}: Vector of spectral coefficients.\ntrunc::Int64: Spectral truncation of the model (e.g. 5 for T5).\n\nReturns\n\nL::LowerTriangularMatrix{ComplexF32}: Complex spectral coefficient matrix.\n\nNotes\n\nFor trunc=5, produces an N=7 x M=6 LowerTriangularMatrix with 27 entries.\nvec is expected to be structured as [Re(c1), …, Re(cncoeff), Im(c1), …, Im(cncoeff)].\n\nExamples\n\nn = calc_n_coeff(trunc=5)\nvec = rand(Float32, 2*n)\nL = vec_to_ltm(vec, 5)\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section contains the code used to produce the results presented in the report, as well as additional examples and outcomes.","category":"page"},{"location":"examples/#Hyperparameter-Optimization","page":"Examples","title":"Hyperparameter Optimization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Under Construction","category":"page"},{"location":"examples/#Long-forecast-quality","page":"Examples","title":"Long forecast quality","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Under Construction","category":"page"},{"location":"examples/#Rossby-Haurwitz-wave","page":"Examples","title":"Rossby-Haurwitz wave","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Under Construction","category":"page"},{"location":"running_SWE/#Running-SpeedyWeatherEmulator.jl","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This section introduces the core functionality of the package.   After a short review of the basic workflow of the package it provides a step-by-step overview of how to generate simulation data, format it for training, build and train an emulator, saving/loading data, and evaluate its performance.","category":"page"},{"location":"running_SWE/#Basic-workflow","page":"Running SpeedyWeatherEmulator.jl","title":"Basic workflow","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This brief introduction to the workflow is meant to illustrate how the different steps, functions, and data types of the package interact. I have deliberately omitted details such as additional functions, parameters, or default values. These can be found in the sections below or seen in action in the examples.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Every workflow in SpeedyWeatherEmulator.jl begins by defining the simulation parameters in a SimPara object. These parameters control the spectral truncation, the number of timesteps to be stored, the number of independent initial conditions and more:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_para = SimPara(trunc=5, n_data=20, n_ic=500)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"With these parameters defined, raw vorticity data is generated using SpeedyWeather.jl and stored on disk.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"generate_raw_data(sim_para)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The raw files are then loaded into a SimData container, which provides a consistent array layout. From this, formatted datasets are built, splitting the vorticity time series into train/validation/test pairs.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_data = SimData(sim_para)\nfd = FormattedData(sim_data)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Next, a neural network architecture is defined and trained on the formatted data. This produces both an Emulator (the trained model) and a Losses object that tracks training progress.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"nn = NeuralNetwork()\nem, losses = train_emulator(nn, fd)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"After the training, the mean relative error and max relative error for one step are printed to STDOUT:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"--------------------------------------\nMean relative error: 13.041 %\nMax relative error:  62.957 %\n--------------------------------------","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The recorded losses can then be visualized:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"display(plot_losses(losses))","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Loss curves)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Finally, we can directly compare emulator predictions with SpeedyWeather.jl outputs. Here we select one vorticity state (vor0), its SpeedyWeather forecast (vorSW), and the emulator’s prediction (vorEM) after three steps. ","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"vor0 = sim_data.data[:,10,500]\nvorSW = sim_data.data[:,13,500]\nvorEM = em(em(em(vor0)))","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Each of them can be visualized as a heatmap,","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"plot_heatmap(vor0, trunc=5, title=\"Initial Vorticity vor0\")\nplot_heatmap(vorSW, trunc=5, title=\"Real SpeedyWeather.jl Vorticity vorSW\")\nplot_heatmap(vorEM, trunc=5, title=\"Predicted Emulator Vorticity vorEM\")","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"resulting in:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Initial Vorticity vor0)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Real SpeedyWeather.jl Vorticity vorSW)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Predicted Emulator Vorticity vorEM)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The difference between the initial vorticity and the final vorticity is small, but it can be seen that the emulator already approximates the real SpeedyWeather.jl data reasonably well.","category":"page"},{"location":"running_SWE/#Generating-and-formatting-data","page":"Running SpeedyWeatherEmulator.jl","title":"Generating and formatting data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Before training a neural network emulator, we need to generate and structure data.   This process has three steps: defining the simulation parameters, running SpeedyWeather.jl to create raw data, and finally preparing formatted datasets for machine learning.","category":"page"},{"location":"running_SWE/#Simulation-Parameters","page":"Running SpeedyWeatherEmulator.jl","title":"Simulation Parameters","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Every workflow begins by specifying the simulation setup in a SimPara object.   This struct collects the essential parameters of a barotropic SpeedyWeather.jl simulation:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"the spectral truncation (trunc, e.g. T5),  \nthe number of stored timesteps after spin-up (n_data),  \nthe number of independent initial conditions (n_ic),  \nand additional metadata such as spin-up length, timestep size, or a unique id_key.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Together, these parameters determine both the structure of the generated data and the folder name under which it is stored.   For example:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"_test\")","category":"page"},{"location":"running_SWE/#Generating-Raw-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Generating Raw Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"With the simulation parameters defined, raw data can be generated directly from SpeedyWeather.jl:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"generate_raw_data(sim_para; overwrite=true)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This command creates a folder with one subdirectory per initial condition and stores the corresponding simulation output. Each run includes spin-up steps, which are used internally but not stored in the final dataset.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Generating raw data can be slow and memory-intensive, since not only vorticity but also auxiliary diagnostics are written to disk. It should therefore be used sparingly, ideally only when new datasets are required. If existing data should not be overwritten, a new id_key can be supplied to disambiguate different runs.","category":"page"},{"location":"running_SWE/#Structured-Simulation-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Structured Simulation Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The raw output is then loaded into a consistent array layout using the SimData constructor:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_data = SimData(sim_para)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The resulting tensor has dimensions [\\text{data} \\in \\mathbb{R}^{(2 \\cdot n\\text{coeff}) \\times n\\text{data} \\times n_\\text{ic}}] where real and imaginary parts of the spectral coefficients are stacked along the first axis. This format is optimized for efficient slicing over time and initial conditions, and serves as the basis for all later steps.","category":"page"},{"location":"running_SWE/#Preparing-Formatted-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Preparing Formatted Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"For machine learning, we need to turn continuous time series into input–output pairs. The FormattedData constructor automates this process by pairing consecutive timesteps:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(x y) = bigl( mathrmvor(t)  mathrmvor(t + Delta t) bigr)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"It then reshapes all samples into column vectors and splits the dataset into training, validation, and test sets. By default, the split is 70 % training, 15 % validation, and 15 % test.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"fd = FormattedData(sim_data; splits=(train=0.7, valid=0.15, test=0.15))","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Since the targets are shifted forward in time, the total number of pairs is (n_data − 1) * n_ic. This ensures that, for instance, y[1] corresponds exactly to the next timestep after x[1].","category":"page"},{"location":"running_SWE/#Training","page":"Running SpeedyWeatherEmulator.jl","title":"Training","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Once the data pipeline is established, we can train a neural network to emulate the barotropic SpeedyWeather.jl model.   This involves defining an architecture, normalizing the data, building an emulator, training it on input–output pairs, and finally comparing predictions against reference data.","category":"page"},{"location":"running_SWE/#Neural-Network-Architecture","page":"Running SpeedyWeatherEmulator.jl","title":"Neural Network Architecture","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The emulator uses a simple feed-forward neural network with ReLU activations.   The architecture is described by a NeuralNetwork object, which specifies the input/output size, the hidden layer width, and the number of hidden layers:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"nn = NeuralNetwork(io_dim=54, hidden_dim=128, n_hidden=2)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This compact container makes it easy to experiment with different model sizes without touching the actual Flux code.","category":"page"},{"location":"running_SWE/#Normalizsation-by-Z-Score","page":"Running SpeedyWeatherEmulator.jl","title":"Normalizsation by Z-Score","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Before training, spectral coefficients are normalized coefficient-wise to zero mean and unit variance. This is achieved with a ZscorePara struct, which stores the mean and standard deviation of the training set. Normalization is always based on the training data alone to avoid information leakage.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"z_i = fracx_i - mu_isigma_i","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The emulator applies this transformation automatically when called","category":"page"},{"location":"running_SWE/#The-Emulator-Wrapper","page":"Running SpeedyWeatherEmulator.jl","title":"The Emulator Wrapper","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The Emulator struct bundles three pieces of information:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"the simulation parameters of the dataset,\nthe neural network chain built from Flux,\nthe Z-score normalization parameters.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This design keeps the metadata and the trained model tightly coupled. For convenience, an emulator can be used like a function:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"y_pred = emu(x)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"where x are spectral coefficients at time t and the output is the emulator prediction at t + Δt.","category":"page"},{"location":"running_SWE/#Logging-Training-Progress","page":"Running SpeedyWeatherEmulator.jl","title":"Logging Training Progress","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"During training, losses are collected in a Losses object. It stores the mean-squared errors for each batch of the training and validation sets, and later also for the test set. This makes it straightforward to plot learning curves and diagnose overfitting.","category":"page"},{"location":"running_SWE/#Training-the-Emulator","page":"Running SpeedyWeatherEmulator.jl","title":"Training the Emulator","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The central routine is train_emulator, which orchestrates the entire process:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Compute Z-score parameters from the training set.\nBuild an Emulator according to the chosen architecture.\nNormalize training and validation data.\nTrain with the Adam optimizer, starting with a given learning rate that halves every 30 epochs.\nRecord training and validation losses batch-by-batch.\nEvaluate the trained emulator on the test set.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"A typical training run looks like this:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"emu, losses = train_emulator(nn, fd; batchsize=64, n_epochs=100, η0=0.0005)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"At the end, the function prints error statistics on the test set and returns both the trained emulator and its recorded loss history.","category":"page"},{"location":"running_SWE/#Evaluating-Accurarcy","page":"Running SpeedyWeatherEmulator.jl","title":"Evaluating Accurarcy","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"To quantify performance, the function compare_emulator applies the trained model to unseen test inputs and compares the predictions against SpeedyWeather.jl reference outputs. It reports mean and maximum relative errors in percent, and can optionally display the error of each spectral coefficient separately. The function also returns the overall average error, which is useful for automated evaluation.  compare_emulator is also used in train_emulator for the test set.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"compare_emulator(emu; \n    x_test=fd.data_pairs.x_test,\n    y_test=fd.data_pairs.y_test,\n    all_coeff=true)","category":"page"},{"location":"running_SWE/#Saving/Loading-data","page":"Running SpeedyWeatherEmulator.jl","title":"Saving/Loading data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Training an emulator often requires repeating experiments with different network architectures or datasets.   To make results reproducible and avoid re-running costly simulations, SpeedyWeatherEmulator.jl provides simple functions for saving and reloading data containers.","category":"page"},{"location":"running_SWE/#Unified-File-Paths","page":"Running SpeedyWeatherEmulator.jl","title":"Unified File Paths","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"All saved objects — whether simulation data, trained emulators, or loss histories — are uniquely identified by their simulation parameters (SimPara).   The helper functions data_path and delete_data ensure that every dataset receives a consistent folder or file name:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Raw data are stored in dedicated folders with one subfolder per run.  \nAll other types (SimData, Emulator, Losses) are saved as single .jld2 files.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The file name includes truncation, number of timesteps, number of initial conditions, and the optional id_key, e.g.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"data/sim_data/sim_data_T5_ndata50_IC200_IDdemo.jld2","category":"page"},{"location":"running_SWE/#Saving-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Saving Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Any supported container can be saved with a single call:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"save_data(sim_data)\nsave_data(emu; overwrite=true)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The type of the object (SimData, Emulator, or Losses) is detected automatically. By default, existing files are not overwritten. If the same identifier is used twice, saving will be canceled unless overwrite=true is specified.","category":"page"},{"location":"running_SWE/#Loading-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Loading Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Previously saved objects can be reloaded at any time:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_data_loaded = load_data(sim_para; type=\"sim_data\")\nemu_loaded      = load_data(sim_para; type=\"emulator\")","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The only requirement is that the SimPara matches the one originally used for saving. The function returns the object in its original type, making it seamless to continue training, evaluate a stored emulator, or plot old loss curves.","category":"page"},{"location":"running_SWE/#Evaluation-and-Visualization","page":"Running SpeedyWeatherEmulator.jl","title":"Evaluation and Visualization","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"After training an emulator, it is often useful to visualize its performance and inspect example vorticity fields.   SpeedyWeatherEmulator.jl provides a small set of plotting functions for these purposes.   The plotting routines are intentionally kept simple: apart from an optional title, no additional styling parameters are exposed, in order to keep the interface clear and focused.","category":"page"},{"location":"running_SWE/#Loss-Curves","page":"Running SpeedyWeatherEmulator.jl","title":"Loss Curves","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The function plot_losses visualizes the training history stored in a Losses object.   It displays:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"the raw training loss per batch (log–log scale),  \nthe mean training loss per epoch,  \nthe mean validation loss per epoch.  ","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This makes it easy to diagnose whether the network is converging properly and whether overfitting occurs.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"emu, losses = train_emulator(nn, fd)\nplot_losses(losses; title=\"Training history (T5)\")","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Loss Plot)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The number of epochs is inferred automatically from the batch size and dataset split. The returned plot object can be further customized or saved using the standard Plots.jl interface.","category":"page"},{"location":"running_SWE/#Vortivity-Heatmaps","page":"Running SpeedyWeatherEmulator.jl","title":"Vortivity Heatmaps","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"To inspect actual states of the barotropic model, the function plot_heatmap reconstructs a vorticity field from a spectral coefficient vector and shows it as a heatmap. This requires specifying the spectral truncation to interpret the coefficient layout correctly:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"vec = rand(Float32, 54)     # random coeffs for trunc=5\nplot_heatmap(vec; trunc=5, title=\"Random vorticity field\")","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Heatmap Plot)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Internally, the coefficients are converted into a lower-triangular matrix and then transformed into a physical-space grid. The resulting heatmap provides an intuitive view of the spatial vorticity pattern represented by the spectral state.","category":"page"},{"location":"#SpeedyWeatherEmulator.jl","page":"Home","title":"SpeedyWeatherEmulator.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SpeedyWeatherEmulator.jl project provides a framework for generating, processing, and emulating spectral vorticity data from the barotropic model in SpeedyWeather.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It enables users to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"configure and run controlled weather simulations,\nstore and format spectral coefficients into training-ready datasets,\ntrain neural network emulators with normalization and logging (Emulator, train_emulator, Losses), and\nevaluate emulator performance against SpeedyWeather baselines with error metrics and visualizations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed to streamline the workflow from simulation to machine learning surrogate modeling, making it easier to test neural network approaches for atmospheric dynamics.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"running.md\", \"ex.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"#Planned-implementations-/-ToDos:","page":"Home","title":"Planned implementations / ToDos:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Planned implementations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implementing code for further testing:\nEmulator quality for Rossby-Haurwitz wave i.c. (as report results / example)\nEmulator quality for multiple consecutive time steps (e.g. 12 * 1h) (as package function + report results)\n***Emulator quality for different simulation data parameters (e.g. for higher truncation) (as report results / example)\n***Implementing a (simple) hyperparameter optimization (as package function + report results)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(***: if not necessary and no time is left until the deadline)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ToDos:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Writing test functions (not yet done, since the program's basic structure has only recently been set up)\nChecking the code quality (e.g. right types, type stability,...)\nThorough testing of the emulator under various conditions to obtain results for the report\nCompletion and revision of docstrings and code comments\nCompletion and revision of GitHub documenation\nWriting the project report","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/SieglStefan/SpeedyWeatherEmulator.jl\")","category":"page"}]
}
