var documenterSearchIndex = {"docs":
[{"location":"functions_index/#Functions-and-Types-index","page":"Functions & Types index","title":"Functions & Types index","text":"","category":"section"},{"location":"functions_index/#Core","page":"Functions & Types index","title":"Core","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Defines the fundamental data structure (SimPara) describing  how simulation data is parameterized. Further it contains helpful utility functions (calc_n_coeff).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.SimPara","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimPara","text":"SimPara{F}\n\nContainer for core simulation parameters that define SpeedyWeather.jl data generation,      resulting data shape and storage name.\n\nFields\n\ntrunc::Int: Spectral truncation of the barotropic model (e.g. 5 for T5).\nn_data::Int: Number of stored data time steps after spin-up.\nn_ic::Int: Number of simulated initial conditions (independent runs).\nn_spinup::Int: Number of spin-up steps discarded before sampling.\nt_step::Float32: Physical time step length.\ninitial_cond::F: Optional generator for initial conditions; if nothing, random ICs are used.\nid_key::String: Additional identifier to disambiguate saved datasets with identical trunc, n_data and n_ic.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.SimPara-Tuple{}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimPara","text":"SimPara(;   trunc,\n            n_data,\n            n_ic,\n            n_spinup = 9,\n            t_step = 1.0,\n            initial_cond = nothing,\n            id_key = \"\")\n\nConvenience constructor for SimPara.\n\nArguments\n\ntrunc::Int: Spectral truncation of the barotropic model (e.g. 5 for T5).\nn_data::Int: Number of stored data time steps after spin-up.\nn_ic::Int: Number of simulated initial conditions (independent runs).\nn_spinup::Int = 9: Number of spin-up steps discarded before sampling (Default data sampling begins at t=10h).\nt_step::Real = 1.0: Physical time step length.\ninitial_cond = nothing: Optional generator for initial conditions; if nothing, random ICs are used. Can also be a Function or any callable object.\nid_key::String = \"\": Additional identifier to disambiguate saved datasets with identical (trunc, n_data, n_ic).\n\nReturns\n\n::SimPara: Container for simulation parameters that define the simulation and data storage.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"_test\")\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.calc_n_coeff-Tuple{}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.calc_n_coeff","text":"calc_n_coeff(; trunc::Int)\n\nCalculate the number of complex spectral coefficients for a given spectral truncation.\n\nArguments\n\ntrunc::Int: Spectral truncation of the barotropic model (e.g. 5 for T5).\n\nReturns\n\nn_coeff::Int: Number of complex spectral coefficients (without splitting into real/imag parts).\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#IO","page":"Functions & Types index","title":"IO","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Provides functions for handling data. Including creating data paths (data_path), deleting data (delete_data), and saving/loading data (save_data, load_data) for specific types.","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.data_path-Tuple{SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.data_path","text":"data_path(sim_para::SimPara; type::String, path::String=\"\")\n\nCreates the folder or file path for storing data associated with sim_para.\n\nArguments\n\nsim_para::SimPara: Simulation parameters (used to build unique name).\ntype::String: Data type; \"raw_data\", \"sim_data\", \"emulator\" or \"losses\".\npath::String = \"\": Optional absolute path for data storage.     If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\n::String: Absolute normalized path to the storage location.\n\nNaming Convention\n\nFor raw data: /data/raw_data/T<trunc>_ndata<n_data>_IC<n_ic>_ID<id_key>/\nFor all other types: /data/<type>/<type>_T<trunc>_ndata<n_data>_IC<n_ic>_ID<id_key>.jld2\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"demo\")\ndata_path(sim_para; type=\"sim_data\")\n# → \".../data/sim_data/sim_data_T5_ndata50_IC200_IDdemo.jld2\"\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.delete_data-Tuple{SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.delete_data","text":"delete_data(sim_para::SimPara; type::String, overwrite::Bool=false, path::String=\"\")\n\nDelete existing data of type \"raw_data\", \"sim_data\", \"emulator\" or \"losses\"\n\nDescription\n\nChecks whether the path already exists.\nIf overwrite=true: deletes existing content.\nIf overwrite=false: keeps existing data untouched and sets cancel_sim=true to cancel current process.\n\nArguments\n\nsim_para::SimPara: Simulation parameters (used for identifying data).\ntype::String: Data type; \"raw_data\", \"sim_data\", \"emulator\", \"losses\".\noverwrite::Bool = false: Control overwrite behavior.\npath::String = \"\": Optional absolute path for data storage.     If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\npath::String: Target folder/file path.\ncancel_sim::Bool: True if the current process must be stopped because data is not allowed to be overwritten.\n\nNotes\n\nFor \"raw_data\", creates a directory tree.\nFor other types, returns the target .jld2 path (no folder created).\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"test\")\ndelete_data(sim_para; type=\"sim_data\")\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.load_data-Union{Tuple{T}, Tuple{Type{T}, SimPara}} where T<:Union{Emulator, Losses, SimData}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.load_data","text":"load_data(::Type{T}, sim_para::SimPara; path::String=\"\") where {T<:Union{SimData, Emulator, Losses}}\n\nLoad previously saved data of a given type using the defining simulation parameters.\n\nArguments\n\n::Type{T}: Dataset type, e.g. SimData, Emulator or Losses.\nsim_para::SimPara: Simulation parameters; determines the folder/file name.\npath::String = \"\": Optional absolute path for data loading.   If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\ndata::T: The saved object stored in the JLD2 file under the key \"data\".   (For example a SimData, Emulator, or Losses object.)\n\nNotes\n\nload_data is intended for JLD2-based single-file storage types.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200)\nsim_data_loaded = load_data(SimData, sim_para)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.save_data-Tuple{Union{Emulator, Losses, SimData}}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.save_data","text":"save_data(data::Union{SimData, Emulator, Losses}; overwrite::Bool=false)\n\nSave simulation- or training-related data (SimData, Emulator, Losses) using JLD2.\n\nDescription\n\nBuilds a consistent file/folder path from the associated SimPara via data_path for saving data.\nPrevents overwriting unless overwrite=true.\nUses JLD2 to serialize the given data.\n\nArguments\n\ndata::Union{SimData, Emulator, Losses}: The container to save.   Must have a field sim_para::SimPara.\noverwrite::Bool = false: If true, existing file/folder is deleted before writing.\npath::String = \"\": Optional absolute path for data saving.   If left empty, the function defaults to the package's internal data/<type> folder.  \n\nReturns\n\nnothing: Data is written to the file system.\n\nNotes\n\nFor raw_data: Creates a directory tree with subfolders run_0001, run_0002, ….\nFor all other types: Saves to a single .jld2 file.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"demo\")\nsim_data = SimData(sim_para)\nsave_data(sim_data; overwrite=true)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#Data","page":"Functions & Types index","title":"Data","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Handles data generation and preparation. This includes creating raw simulation data with SpeedyWeather.jl (generate_raw_data), wrapping it into structured containers (SimData), and formatting it into train/validation/test sets (DataPairs, FormattedData).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.generate_raw_data-Tuple{SimPara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.generate_raw_data","text":"generate_raw_data(sim_para::SimPara; overwrite::Bool=false, path::String=\"\")\n\nGenerate raw vorticity data with SpeedyWeather.jl based on the given simulation parameters.\n\nDescription\n\nRuns the barotropic model with spectral truncation sim_para.trunc and time step sim_para.t_step.\nFor each initial condition (IC), creates a new run subfolder and stores the simulated vorticity.\nIf overwrite=false and data already exist, generation is canceled.\n\nArguments\n\nsim_para::SimPara: Container for parameters that define the simulation and data storage.\noverwrite::Bool = false: If true, delete existing data and regenerate.     If false, aborts safely when data already exist.\npath::String = \"\": Optional absolute path for data storage.     If left empty, the function defaults to the package's internal data/<type> folder.\n\nReturns\n\n::Bool: Returns a boolean value that indicates if the data was generated successfully.\n\nNotes\n\nSpin-up steps (n_spinup) are run but not stored in later SimData.\nIf sim_para.initial_cond is not nothing, this function applies the given IC via set!(sim, vor=…).\nSometimes overwriting raw_data files is not possible because the folders are open/busy.   Data Generation is then canceled.\nOnly prognostic variables are stored.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"123\")\ngenerate_raw_data(sim_para; overwrite=true)\n# → creates data/raw_data/raw_data_T5_ndata50_IC200_ID123/run_0001/output.jld2, ..., run_0200/output.jld2\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.SimData","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimData","text":"SimData(sim_para::SimPara, path::String=\"\")\n\nConstruct a SimData container by loading previously generated raw data and extracting the spectral vorticity coefficients time series into a consistent tensor layout.\n\nThis constructor:\n\ninfers (n_coeff, n_data, n_ic) from sim_para,\nallocates the target array data::Array{Float32,3} with shape (2 * n_coeff, n_data, n_ic),\niterates over runs ic = 1:n_ic, loads output.jld2, and reads output_vector,\nfor each stored step step ∈ {n_spinup+1, …, n_spinup + n_data}:\nextracts the spectral vorticity vor,\nwrites real(vor) to rows 1:n_coeff and imag(vor) to rows n_coeff+1:2n_coeff,\nstores at time index step - n_spinup.\n\nArguments\n\nsim_para::SimPara{F}: Container for parameters that define the simulation and data storage;    must match the generated raw data on disk.\npath::String = \"\": Optional absolute path of stored raw_data.     If left empty, the function defaults to the package's internal data/<type> folder.\n\nReturns\n\n::SimData{F, Array{Float32,3}}: Container holding simulation data and corresponding sim. parameters.\n\nPreconditions\n\nExpects raw data in data_path(sim_para; type=\"raw_data\") with per-run subfolders   run_0001, run_0002, … each containing output.jld2 with an output_vector.\nRaw data should be created beforehand via generate_raw_data(sim_para; overwrite=false).\n\nNotes\n\nThe leading factor 2 in the first dimension stacks real and imaginary parts.\nThe time indexing uses step - n_spinup to map stored steps to 1:n_data.\n\nExamples\n\nsim_para = SimPara(trunc=5, n_data=50, n_ic=200)\n# after generate_raw_data(sim_para) has been called:\nsim_data = SimData(sim_para)\n# inspect shapes\nsize(sim_data.data)  # (2*n_coeff, n_data, n_ic)\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.SimData-2","page":"Functions & Types index","title":"SpeedyWeatherEmulator.SimData","text":"SimData{F, A<:AbstractArray{Float32, 3}}\n\nContainer for SpeedyWeather.jl vorticity data together with the simulation parameters.\n\nFields\n\nsim_para::SimPara{F}: Container for parameters that define the simulation and data storage.\ndata::A: Vorticity tensor with shape (2 * n_coeff, n_data, n_ic)       where n_coeff = calc_n_coeff(sim_para.trunc).        The first n_coeff rows store the real parts,        the next n_coeff rows the imaginary parts of the complex spectral coefficients.\n\nNotes\n\nThe layout is column-major and optimized for contiguous slicing over time and ICs.\nDimensions are inferred from sim_para and remain consistent across the pipeline.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.DataPairs","page":"Functions & Types index","title":"SpeedyWeatherEmulator.DataPairs","text":"DataPairs{A<:AbstractArray{Float32, 2}}\n\nContainer for paired data samples (x,y) = (vor(t), vor(t+Δt)), already split into training, validation and test sets.\n\nFields\n\nx_train::A: Training inputs vor(t).\ny_train::A: Training targets vor(t+Δt).\nx_valid::A: Validation inputs vor(t).\ny_valid::A: Validation targets vor(t+Δt).\nx_test::A: Test inputs vor(t).\ny_test::A: Test targets vor(t+Δt).\n\nNotes\n\nAll matrices have the same row dimension = 2 * n_coeff.\nColumns index over independent time-pairs and ICs.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.FormattedData","page":"Functions & Types index","title":"SpeedyWeatherEmulator.FormattedData","text":"FormattedData{F, A<:AbstractArray{Float32, 2}}\n\nContainer for formatted data, i.e. paired vorticity samples (x,y) = (vor(t), vor(t+Δt)).\n\nFields\n\nsim_para::SimPara{F}: Container for parameters that define the simulation and data storage.\ndata_pairs::DataPairs{A}: The split and paired data.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.FormattedData-Tuple{SimData}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.FormattedData","text":"FormattedData(  sim_data::SimData; \n                splits::NamedTuple{(:train, :valid, :test),<:Tuple{Vararg{Real,3}}} = \n                    (train=0.7, valid=0.15, test=0.15))\n\nConstruct FormattedData directly from SimData by pairing consecutive time steps     and splitting them into train/validation/test sets.\n\nDescription\n\nBuilds (x,y) pairs as\nx = vor(t) = spectral vorticity state at time t,\ny = vor(t+Δt) at the next time step.\nReshapes all ICs and times into column vectors.\nSplits the resulting pairs according to the fractions in splits.\n\nArguments\n\nsim_data::SimData: Container holding simulation data and corresponding sim. parameters.\nsplits::NamedTuple{(:train, :valid, :test),<:Tuple{Vararg{Real,3}}}: Fractions for train-, valid- and test-set.     Default = (0.7, 0.15, 0.15).\n\nReturns\n\n::FormattedData: Container holding formatted (paired) simulation data and corresponding sim. parameters.\n\nNotes\n\nThe number of total pairs is (n_data - 1) * n_ic.\nSplits are normalized so that train + valid + test = 1.\n\nExamples\n\nfd = FormattedData(sim_data; splits=(train=0.7, valid=0.2, test=0.1))\nsize(fd.data_pairs.x_train)  # (2*n_coeff, n_train)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#Emulator","page":"Functions & Types index","title":"Emulator","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Handles emulator definition, normalization, training, and evaluation. This includes Z-score normalization utilities (ZscorePara, zscore, inv_zscore), core emulator types (NeuralNetwork, Emulator, Losses), training workflow (train_emulator), and evaluation against SpeedyWeather.jl reference data (compare_emulator).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.ZscorePara","page":"Functions & Types index","title":"SpeedyWeatherEmulator.ZscorePara","text":"ZscorePara{F<:AbstractVector{Float32}}\n\nContainer for the parameters of a Z-score transformation.\n\nFields\n\nμ::F: Mean for each coefficient across samples.\nσ::F: Std for each coefficient across samples.\n\nNotes\n\nTypically computed from the training set only to avoid data leakage.\nFor each coefficient indexed i: zi = (xi - μi) / (σi + eps)\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.inv_zscore-Tuple{AbstractArray{Float32}, ZscorePara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.inv_zscore","text":"inv_zscore(x::AbstractArray{Float32}, stats::ZscorePara{<:AbstractVector{Float32}})\n\nInverse Z-score transformation (restore original scale).\n\nArguments\n\nx::AbstractArray{Float32}: Z-score normalized data.\nstats::ZscorePara{<:AbstractVector{Float32}}: Parameters with mean μ and std σ.\n\nReturns\n\n::typeof(x): Data rescaled back to the original distribution.\n\nExamples\n\nstats = ZscorePara([0.0f0, 1.0f0], [1.0f0, 2.0f0])\nz = Float32[0 -0.5; 1 0.5]\nx = inv_zscore(z, stats)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.zscore-Tuple{AbstractArray{Float32}, ZscorePara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.zscore","text":"zscore(x::AbstractArray{Float32}, stats::ZscorePara{<:AbstractVector{Float32}})\n\nApply a Z-score transformation to data x using the parameters in stats.\n\nArguments\n\nx::AbstractArray{Float32}: Input data (rows = coefficients, columns = samples).\nstats::ZscorePara{<:AbstractVector{Float32}}: Parameters with mean μ and std σ.\n\nReturns\n\n::typeof(x): Z-score normalized data.\n\nNotes\n\nEach coefficient is transformed independently.\nA small eps(Float32) is added to σ to avoid division by zero.\n\nExamples\n\nstats = ZscorePara([0.0f0, 1.0f0], [1.0f0, 2.0f0])\nx = Float32[0 2; 1 3]\nz = zscore(x, stats)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.Emulator","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Emulator","text":"Emulator{A<:AbstractVector{Float32}}\n\nContainer for a trained (or in-progress) neural network emulator.\n\nFields\n\nsim_para::SimPara: Simulation parameters of the dataset used for training, validation and testing.\nchain::Flux.Chain: Neural network architecture and weights.\nzscore_para::ZscorePara{A}: Normalization parameters (mean/std of training set).\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.Emulator-Tuple{AbstractArray{Float32}}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Emulator","text":"(m::Emulator)(x::AbstractArray{Float32})\n\nConvenience call overload. Apply the trained emulator to spectral coefficients at time t to predict coefficients at t + Δt.\n\nArguments\n\nx::AbstractArray{Float32}: Spectral coefficients of vorticity at time t. First dimension must be 2 * n_coeff.\n\nReturns\n\n::typeof(x): Emulator prediction for a vorticity at t + Δt (same size as input array).\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.Emulator-Tuple{SimPara, NeuralNetwork, ZscorePara}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Emulator","text":"Emulator(sim_para::SimPara, nn::NeuralNetwork, zscore_para::ZscorePara)\n\nConstructor for an Emulator. Builds a feed-forward network with ReLU activations according to the given NeuralNetwork specs.\n\nArguments\n\nsim_para::SimPara: Simulation parameters used for generating the training data.\nnn::NeuralNetwork: Parameters of the architecture (layer sizes).\nzscore_para::ZscorePara: Normalization parameters of the training data.\n\nReturns\n\n::Emulator: A wrapped Flux model with normalization metadata.\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.Losses","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Losses","text":"Losses{F}\n\nContainer for logging training and validation losses and training time.\n\nFields\n\nsim_para::SimPara{F}: Simulation parameters of the dataset used.\ntrain::Vector{Float32}: Training loss per batch.\nvalid::Vector{Float32}: Validation loss per batch.\nbpe_train::Int: Batches per epoch (training set).\nbpe_valid::Int: Batches per epoch (validation set).\ntraining_time::Float32: Time needed for training the model in seconds.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.Losses-Tuple{SimPara, Any, Any}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.Losses","text":"Losses(sim_para::SimPara, bpe_train, bpe_valid)\n\nConstructor for an empty Losses container.\n\nArguments\n\nsim_para::SimPara{F}: Simulation parameters of the dataset used.\nbpe_train::Int: Batches per epoch (training set).\nbpe_valid::Int: Batches per epoch (validation set).\n\nReturns\n\n::Losses{F}: Initialized container with empty loss vectors and training_time = 0.0.\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.NeuralNetwork","page":"Functions & Types index","title":"SpeedyWeatherEmulator.NeuralNetwork","text":"NeuralNetwork\n\nContainer for the layer dimensions of a neural network.\n\nFields\n\nio_dim::Int: Dimension of the input and output layer (e.g. number of spectral coefficients).\nhidden_dim::Int: Dimension of each hidden layer.\nn_hidden::Int: Number of hidden layers.\n\n\n\n\n\n","category":"type"},{"location":"functions_index/#SpeedyWeatherEmulator.NeuralNetwork-Tuple{}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.NeuralNetwork","text":"NeuralNetwork(; io_dim::Int=54, hidden_dim::Int=640, n_hidden::Int=1)\n\nConvenience constructor for NeuralNetwork.\n\nArguments\n\nio_dim::Int = 54: Dimension of the input and output layer (e.g. number of spectral coefficients). Standard is the T5 model.\nhidden_dim::Int = 640: Dimension of each hidden layer. Optimal value, obtained by hyperparameter optimization.\nn_hidden::Int = 1: Number of hidden layers. Optimal value, obtained by hyperparameter optimization.\n\nReturns\n\n::NeuralNetwork: Parameter container.\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.compare_emulator-Tuple{Emulator}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.compare_emulator","text":"compare_emulator(   em::Emulator; \n                    x_test::AbstractArray{Float32, 2},\n                    y_test::AbstractArray{Float32, 2},\n                    n_it::Int=1,\n                    output::Bool=false,\n                    all_coeff::Bool=false,\n                    id_em::Bool=false)\n\nCompare emulator predictions against SpeedyWeather.jl reference data.\n\nDescription\n\nApplies the emulator em to test inputs x_test and compares results to y_test for n_it timesteps.\nComputes mean relative error per spectral coefficient:    relerri = |ŷi - yi| / (|y_i| + ε) * 100.\nPrints mean relative error (all coefficients averaged) and maximum mean relative error.\nOptionally prints coefficient-wise relative errors.\n\nArguments\n\nem::Emulator: Trained emulator to evaluate.\nx_test::AbstractArray{Float32, 2}: Test inputs (vorticity coefficients at t) of form (2 * n_coeff, N).\ny_test::AbstractArray{Float32, 2}: Reference outputs from SpeedyWeather.jl (at t+nit*Δt) of form (2 * ncoeff, N).\nn_it::Int: Number of timesteps compared.\noutput::Bool=false: If true, print to STDOUT.\nall_coeff::Bool=false: If true (and also output=true) print relative error for each coefficient.\nid_em::Bool=false: The identity emulator is used (em(vor(t)) = vor(t))\n\nReturns\n\nmean_mean_rel::Float32: The mean (all spectral coeff.) mean (all possible datapairs) relative error for n_it timesteps.\n\nNotes\n\nThe larger n_it, the fewer data pairs are available for comparison. For example:   n_data=4 and n_it=2 leads to data pairs 1-2-3 and 2-3-4.\nSome coefficients in SpeedyWeather.jl are structurally zero → flagged in output.\nErrors are reported in percent [%].\n\nExamples\n\nem, losses = train_emulator(nn, fd)\ncompare_emulator(em; \n    x_test=fd.data_pairs.x_test,\n    y_test=fd.data_pairs.y_test,\n    all_coeff=true)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.train_emulator-Tuple{NeuralNetwork, FormattedData}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.train_emulator","text":"train_emulator( nn::NeuralNetwork, \n                fd::FormattedData; \n                sim_para::SimPara=fd.sim_para, \n                batchsize::Int = 32, n_epochs::Int=300, η0::Real=0.001)\n\nTrain an emulator (neural network) with the given architecture and data.\n\nDescription\n\nComputes Z-score parameters from the training set.\nConstructs an Emulator with the given NeuralNetwork.\nApplies Z-score normalization to training and validation pairs.\nTrains the network using Adam with initial learning rate η0.\nHalves the learning rate every 30 epochs.\nLogs training and validation losses.\nCalls compare_emulator on the test set after training.\n\nArguments\n\nnn::NeuralNetwork: Defines the structure (layer sizes) of the neural network.\nfd::FormattedData: Formatted dataset with train/valid/test splits of size (2*n_coeff, N).\nsim_para::SimPara=fd.sim_para: Optional different simulation parameters for better saving.\nbatchsize::Int=32: Training batch size.\nn_epochs::Int=300: Number of training epochs.\nη0::Real=0.001: Initial learning rate.\n\nReturns\n\nem::Emulator: Trained emulator model (Flux chain + normalization).\nlosses::Losses: Recorded training/validation losses and batches per epoch.\n\nNotes\n\nTest set evaluation is not part of the training loop; only compare_emulator is called at the end.\nNormalization statistics are always computed from the training set to avoid leakage.\n\nExamples\n\nnn = NeuralNetwork(io_dim=54, hidden_dim=128, n_hidden=2)\nfd = FormattedData(sim_data; splits=(train=0.7, valid=0.2, test=0.1))\nem, losses = train_emulator(nn, fd; batchsize=64, n_epochs=100, η0=0.0005)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#Evaluation","page":"Functions & Types index","title":"Evaluation","text":"","category":"section"},{"location":"functions_index/","page":"Functions & Types index","title":"Functions & Types index","text":"Handles evaluation and visualization of emulator and simulation output. This includes plotting loss plots (plot_losses), and reconstructing vorticity fields from spectral coefficients as heatmaps (plot_heatmap).","category":"page"},{"location":"functions_index/#SpeedyWeatherEmulator.plot_losses-Tuple{Losses}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.plot_losses","text":"plot_losses(losses::Losses; title::String=\"Emulator Losses\")\n\nPlot training and validation losses stored in a Losses container.\n\nDescription\n\nPlots training loss per batch (log-log scale).\nAdds epoch-averaged training and validation loss curves.\nReturns a Plots.Plot object for further customization or saving.\n\nArguments\n\nlosses::Losses: Container with training/validation loss history and number of batches per epoch.\ntitle::String=\"Emulator Losses\": Optional argument for different plot titles (e.g. different simulation parameters).\n\nReturns\n\np::Plots.Plot: Combined plot of training and validation losses.\n\nNotes\n\nTraining batches per epoch = losses.bpe_train.\nValidation batches per epoch = losses.bpe_valid.\nNumber of epochs is inferred as length(losses.train) / bpe_train.\n\nExamples\n\nemu, losses = train_emulator(nn, fd)\np = plot_losses(losses)\ndisplay(p)  \n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.plot_heatmap-Tuple{AbstractVector{Float32}}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.plot_heatmap","text":"plot_heatmap(vec::AbstractVector{Float32}; trunc::Int, title::String=\"\", range::Tuple{Real,Real}=(-5e-5, +5e-5))\n\nPlot a heatmap of a vorticity field reconstructed from a spectral coefficient vector.\n\nDescription\n\nConverts spectral coefficients in vector form into a LowerTriangularMatrix.\nTransforms this into a grid suitable for plotting.\nDisplays the grid as a heatmap using CairoMakie.\n\nArguments\n\nvec::AbstractVector{Float32}: Spectral coefficient vector (real/imag stacked).\ntrunc::Int: Spectral truncation of the model (e.g. 5 for T5).\ntitle::String = \"\": Optional argument for different plot titles (e.g. different simulation parameters).\nrange::Tuple{Real,Real} = (-5e-5, +5e-5): Defines the color range of the heatmap plot.\n\nReturns\n\n::CairoMakie.Heatmap: Heatmap figure object.\n\nExamples\n\nvec = rand(Float32, 54)   # random spectral coeffs for trunc=5\nfig = plot_heatmap(vec; trunc=5, title=\"Vorticity field\")\ndisplay(fig)\n\n\n\n\n\n","category":"method"},{"location":"functions_index/#SpeedyWeatherEmulator.vec_to_ltm-Tuple{AbstractVector{Float32}, Int64}","page":"Functions & Types index","title":"SpeedyWeatherEmulator.vec_to_ltm","text":"vec_to_ltm(vec::AbstractVector{Float32}, trunc::Int)\n\nConvert a spectral coefficient vector into a LowerTriangularMatrix representation.\n\nDescription\n\nInterprets the coefficient vector as complex spectral coefficients.\nPlaces them into a triangular matrix layout consistent with SpeedyWeather.jl.\n\nArguments\n\nvec::AbstractVector{Float32}: Vector of spectral coefficients.\ntrunc::Int: Spectral truncation of the model (e.g. 5 for T5).\n\nReturns\n\nL::LowerTriangularMatrix{ComplexF32}: Complex spectral coefficient matrix.\n\nNotes\n\nFor trunc=5, produces an N=7 x M=6 LowerTriangularMatrix with 27 entries.\nvec is expected to be structured as [Re(c1), …, Re(cncoeff), Im(c1), …, Im(cncoeff)].\n\nExamples\n\nn = calc_n_coeff(trunc=5)\nvec = rand(Float32, 2*n)\nL = vec_to_ltm(vec, 5)\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section provides explanation of code used to produce the results presented in the project report, along with additional examples and outputs. The plotting routines themselves are not listed here, but interested readers can find the corresponding code under the folder examples in the repository. In addition, the actual code is structured somewhat differently (e.g., the separation into performance and evaluation parts) from the simplified demonstrations shown in this documentation. Nevertheless, the scripts are extensively commented, making them straightforward to follow.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Project Report provides a quick overview of the examples without code snippets. Furthermore, it briefly introduces the necessity and background of emulators and explains and discusses the results, which is not done here.","category":"page"},{"location":"examples/#Hyperparameter-Optimization","page":"Examples","title":"Hyperparameter Optimization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, a hyperparameter optimization (width and depth of the neural network) is performed, consisting of a coarse and fine optimization.","category":"page"},{"location":"examples/#Data-Generation","page":"Examples","title":"Data Generation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For this purpose, the simulation parameters sim_para are defined, raw data is generated and stored, and the corresponding simulation data sim_data produced and saved. In all subsequent examples, these sim_data is used directly, so the raw data is no longer required and can be deleted if desired (e.g. storage reasons). The data is then further formatted into data pairs:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define simulation parameters\nconst TRUNC = 5\nconst N_DATA = 48\nconst N_IC = 1000\n\nsim_para = SimPara(trunc=TRUNC, n_data=N_DATA, n_ic=N_IC)\n\n# Generate raw data\ngenerate_raw_data(sim_para)\n\n# Generate simulation data and save it\nsim_data = SimData(sim_para)\nsave_data(sim_data)\n\n# Generate formatted data\nfd = FormattedData(sim_data)","category":"page"},{"location":"examples/#Coarse-Optimization","page":"Examples","title":"Coarse Optimization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We first perform a coarse optimization using the following values for depth (L) and width (W):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"L_list_coarse = [1,2,3]                 # depth: number of hidden layers\nW_list_coarse = [64, 128, 256, 512]     # width: number of neurons per hidden layer","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we run a short and simple initial training using nn_warmup to ensure that the time logging is not distorted:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"nn_warmup = NeuralNetwork(io_dim=2*calc_n_coeff(trunc=TRUNC),\n                          hidden_dim=8,\n                          n_hidden=1)\n\n_, _ = train_emulator(nn_warmup, fd; n_epochs=1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"After this initial warm-up, we are now ready to train the emulators for the different depths and widths. A total of 12 combinations are tested. This is computationally intensive and may take several hours on simple standard machines. Therefore, the emulators and losses are also saved for later use, so that the optimization does not need to be repeated.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Training loop\nfor L in L_list_coarse, W in W_list_coarse\n\n    # Define simulation parameters for specific hyperparameter\n    id = \"_hyperpara_L$(L)_W$(W)\"\n    sim_para = SimPara(trunc=TRUNC, n_data=N_DATA, n_ic=N_IC, id_key=id)\n\n    # Define neural network and train the emulator\n    nn = NeuralNetwork( io_dim=2*calc_n_coeff(trunc=TRUNC),\n                        hidden_dim = W,\n                        n_hidden = L)\n\n    em, losses = train_emulator(nn, fd; sim_para=sim_para)\n\n    # Save losses and data for later evaluation\n    save_data(em)\n    save_data(losses)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we define a function n_params to calculate the total number of parameters of a neural network. In addition, we define a dictionary plot_data to conveniently store plotting data for different (L, W) combinations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"n_params(d, W, L) = (d*W + W) + (L-1)*(W*W + W) + (W*d + d)\n\nplot_data = Dict{Tuple{Int,Int}, NamedTuple}()      ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we want to populate the dictionary with the relative errors for various forecast times (horizons) and the total number of parameters for all (L,W) combinations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define comparing time horizons\nhorizons = [1, 6, 12, 24]\n\n# Fill the plot data dict. for all coarse hyperparameter\nfor L in L_list_coarse, W in W_list_coarse\n\n    # Define simulation parameters for specific hyperparameter for leading specific emulator\n    id = \"_hyperpara_L$(L)_W$(W)\"\n    sim_para = SimPara(trunc=TRUNC, n_data=N_DATA, n_ic=N_IC, id_key=id)\n\n    # Load the specific emulator (generated by training loop above)\n    em = load_data(Emulator, sim_para)\n\n    # Define container for rel. errors for different horizons\n    err_vec = zeros(N_DATA)\n\n    # Compare the emulator for different horizons\n    for steps in horizons\n        err_vec[steps] = compare_emulator(  em,\n                                            x_test=fd.data_pairs.x_valid,\n                                            y_test=fd.data_pairs.y_valid,\n                                            n_it=steps)\n\n    end\n\n    # Fill the dict\n    plot_data[(L,W)] = (err=err_vec, params=n_params(2*calc_n_coeff(trunc=TRUNC), W, L))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These results are then plotted:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Coarse Optimization)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The code for generating the plots can be found in the package repository.","category":"page"},{"location":"examples/#Fine-Optimization","page":"Examples","title":"Fine Optimization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, a finer optimization is performed around the best value from the coarse search (L = 1, W = 512) using the following values:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"L_list_fine = [1]                           # depth: number of hidden layers\nW_list_fine = [384, 512, 640, 768, 896, \n                1024, 1280, 1536, 2048]     # width: number of neurons per hidden layer","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The procedure is very similar and is not repeated here. Interested readers can find the details in the repository. The results are plotted again:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Fine Optimization)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For later applications, the combination (L = 1, W = 640) is chosen as the best parameters, as it provides the best compromise between emulator quality and training time. This combination is also the default for the NeuralNetwork object.","category":"page"},{"location":"examples/#Parameters-vs.-Time","page":"Examples","title":"Parameters vs. Time","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the plots above, emulator quality was shown against the total number of parameters of the neural network. This raises the further question of how the different (L, W) combinations perform in terms of time. A good emulator should provide high prediction quality but should also not take excessively long to train. How, then, are training time and parameter count related? To investigate this, training time versus parameter count is plotted:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Parameters vs time)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A clear linear correlation can be observed. Training time and parameter count are therefore essentially synonymous. The corresponding code is again available in the repository.","category":"page"},{"location":"examples/#Long-Forecast-Quality","page":"Examples","title":"Long Forecast Quality","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, the prediction quality for different forecast lengths is examined in more detail. For this purpose, we use the simulation data generated during the Hyperparameter Optimization by loading the stored data and subsequently formatting them:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Load and format simulation data, generated by the hyperparameter optimization\nconst TRUNC = 5\nconst N_DATA = 48\nconst N_IC = 1000\n\nsim_para_loading = SimPara(trunc=TRUNC, n_data=N_DATA, n_ic=N_IC)\nsim_data = load_data(SimData, sim_para_loading)\nfd = FormattedData(sim_data)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, the best emulator from the hyperparameter optimization (L = 1, W = 640) is loaded. For this purpose, a separate sim_para_emulator must be defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Loading the best emulator from the hyperparameter optimiaztion\nsim_para_emulator = SimPara(trunc=TRUNC, n_data=N_DATA, n_ic=N_IC, id_key=\"_hyperpara_L1_W640\")\nem = load_data(Emulator, sim_para_emulator)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then, the data vectors err_vec and err_vec0 storing rel. errors are defined. err_vor simply contains the averaged relative error of the emulator for different horizons, while err_vor0 contains the averaged relative error of the identity emulator. Thus, err_vec0 represents the relative error between mathrmvor(t + mathrmsteps) and mathrmvor(t) as a measure of the actual change in vorticity for comparison.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the rel. errors \nfor steps in 1:N_DATA\n    err_vec[steps] = compare_emulator(  em,\n                                        x_test=fd.data_pairs.x_test,\n                                        y_test=fd.data_pairs.y_test,\n                                        n_it=steps)\n    err_vec0[steps] = compare_emulator( em,\n                                        x_test=fd.data_pairs.x_test,\n                                        y_test=fd.data_pairs.y_test,\n                                        n_it=steps,\n                                        id_em=true)     # identy emulator (em(vor) = vor)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Different values for the maximum forecast length (here N_DATA) can of course also be used. This data is now plotted again:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Long forecast emulator quality)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: long forecast emulator comparison)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For further details, see the repository and/or project report. ","category":"page"},{"location":"examples/#Heatmap-Plots","page":"Examples","title":"Heatmap Plots","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we create a visual representation of emulator quality using plot_heatmap. To this end, we select the forecast horizons to be plotted and extract corresponding vorticity vectors by specifying the index of the initial condition ic.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define the time horizons for comparison and used initial condition\nhorizons = [1, 6, 24, 48]\nic = 6","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Here, ic = 6 was chosen because its vorticity vectors produce clear plots.) We then compute the target and emulated vorticity step by step and plot the corresponding heatmaps:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Loop for different time horizons\nfor h in horizons\n    # Initial vorticity\n    vor0 = sim_data.data[:, 1, ic]\n\n    # Target (SpeedyWeather.jl) and emulated vorticity\n    vor_sw = sim_data.data[:, h, ic]\n    vor_em = vor0\n\n    for _ in 1:h\n        vor_em = em(vor_em)\n    end\n\n    # Create heatmap plots\n    colorrange = (-2.5e-5, +2.5e-5)\n    fig_sw = plot_heatmap(vor_sw, trunc=5, title=\"\", range=colorrange)\n    fig_em = plot_heatmap(vor_em, trunc=5, title=\"\", range=colorrange)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This results in many individual heatmaps. These heatmaps are not shown here but were subsequently combined into a single large figure using Inkscape:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Long forecast heatmap)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For further details, see the repository and/or project report. ","category":"page"},{"location":"examples/#Rossby-Haurwitz-wave","page":"Examples","title":"Rossby-Haurwitz wave","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"So far, the emulator has only been tested on random initial conditions, i.e., on data with the same structure it was trained on. We now want to examine how the emulator responds to special cases. For this purpose, we consider the Rossby–Haurwitz wave, which propagates steadily around the Earth. Thus, we define the Rossby–Haurwitz initial state as the initial condition:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define Rossby-Haurwitz wave initial condiion\nm = 4\nω = 7.848e-6\nK = 7.848e-6\n\nζ(λ, θ, σ) = 2ω*sind(θ) - K*sind(θ)*cosd(θ)^m*(m^2 + 3m + 2)*cosd(m*λ)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This code snippet was taken from the documentation of SpeedyWeatherEmulator.jl, which in turn refers to the paper ‘A standard test set for numerical approximations to the shallow water equations in spherical geometry’ by David L. Williamson, John B. Drake, James J. Hack, Rüdiger Jakob, and Paul N. Swarztrauber. See the project report for details on references.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"With this initial condition defined, we can now generate simulation data for comparison. To do so, the initial condition must be passed to SimPara, which then forwards it to generate_raw_data, where SpeedyWeather.jl uses it to generate data. Subsequently, the data is formatted again. Since we only require test data, the splits are set to splits = (0, 0, 1):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define test data\nsim_para_RH = SimPara(trunc=5, n_data=48, n_ic=1, initial_cond=ζ, id_key=\"_RH_wave\", n_spinup=0)\ngenerate_raw_data(sim_para_RH)\nsim_data_RH = SimData(sim_para_RH)\nfd_RH = FormattedData(sim_data_RH, splits=(train=0, valid=0, test=1))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The subsequent procedure is analogous to Long Forecast Quality. An emulator is loaded, the relative errors are computed, and the data is plotted. See the repository and/or project report for details. The resulting plots are shown below:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: RH emulator comparison)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: RH Heatmap)","category":"page"},{"location":"running_SWE/#Running-SpeedyWeatherEmulator.jl","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This section introduces the core functionality of the package. After a short review of the basic workflow it provides a step-by-step overview of how to generate simulation data, format it for training, build and train an emulator, saving/loading data, and evaluate its performance.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"For the plots in this chapter, a separate, slightly modified script was used. If you are particularly interested in this details, you can find the exact code used for plot creation in the repository folder plot_utils/docs_plots_running_SWE.","category":"page"},{"location":"running_SWE/#Basic-Workflow","page":"Running SpeedyWeatherEmulator.jl","title":"Basic Workflow","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This brief introduction to the workflow is meant to illustrate how the different steps, functions, and data types of the package interact. I have deliberately omitted details such as additional functions, parameters, or default values. These can be found in the sections below, seen in action in the examples or looked up in the source code.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Every workflow in SpeedyWeatherEmulator.jl begins by defining the simulation parameters in a SimPara object. These parameters control the spectral truncation, the number of datapoints to be stored per i.c., the number of independent initial conditions and more:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_para = SimPara(trunc=5, n_data=24, n_ic=800, id_key=\"_basic_workflow\")","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"With these parameters defined, raw vorticity data is generated using SpeedyWeather.jl and stored on disk.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"generate_raw_data(sim_para)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The raw files are then loaded into a SimData container, which provides a consistent array layout. From this, formatted datasets are built, splitting the vorticity time series into train/validation/test pairs.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_data = SimData(sim_para)\nfd = FormattedData(sim_data)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Next, a neural network architecture is defined and trained on the formatted data. This produces both an Emulator (the trained model) and a Losses object that tracks training progress.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"nn = NeuralNetwork()\nem, losses = train_emulator(nn, fd)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"After the training, the mean relative error and max relative error for one step are printed to STDOUT:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"--------------------------------------\nMean relative error: 3.528 %\nMax relative error:  6.673 %\n--------------------------------------","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The recorded losses can then be visualized:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"plot_losses(losses)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Loss curves)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Finally, we can visually compare emulator predictions with SpeedyWeather.jl outputs. Here we select one vorticity state (vor0), its SpeedyWeather forecast (vorSW), and the emulator’s prediction (vorEM) after six steps. This corresponds to a six hour forecast:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"vor0 = fd.data_pairs.x_test[:,10,1]\nvor_sw = fd.data_pairs.y_test[:,10+6,1]\n\n# Calculate emulator vorticity\nvor_em = vor0\nfor _ in 1:6\n    global vor_em = em(vor_em)\nend","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Each of them can be visualized as a heatmap,","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"colorrange = (-2.5e-5, +2.5e-5)\nplot_heatmap(vor0, trunc=5, title=\"Initial Vorticity vor0\", range=colorrange)\nplot_heatmap(vor_sw, trunc=5, title=\"Target Vorticity vor_sw\", range=colorrange)\nplot_heatmap(vor_em, trunc=5, title=\"Emulated Vorticity vor_em\", range=colorrange)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"resulting in:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Initial Vorticity vor0)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Taget Vorticity vor_sw)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Emulated Vorticity vor_em)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The difference between the initial vorticity and the final vorticity is small, but it can be seen that the emulator already approximates the target SpeedyWeather.jl data reasonably well.","category":"page"},{"location":"running_SWE/#Generating-and-Formatting-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Generating and Formatting Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Before training a emulator, we need to generate and structure data.   This process has three steps: defining the simulation parameters, running SpeedyWeather.jl to create raw data, and finally preparing formatted datasets for machine learning.","category":"page"},{"location":"running_SWE/#Simulation-Parameters","page":"Running SpeedyWeatherEmulator.jl","title":"Simulation Parameters","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Every workflow begins by specifying the simulation setup in a SimPara object.   This struct collects the essential parameters of a barotropic SpeedyWeather.jl simulation:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"the spectral truncation (trunc, e.g. T5),  \nthe number of stored timesteps after spin-up (n_data),  \nthe number of independent initial conditions (n_ic),  \nand additional metadata such as spin-up length, timestep size, or a unique id_key.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Together, these parameters determine both the structure of the generated data. For example:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=\"_test1\")","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"It should be emphasized that only the fields used in the example above are responsible for saving and loading data. In general, it is recommended not to rely solely on the identifiers trunc, n_data, and n_ic, but to always provide an additional id_key as well! See Saving/Loading Data for details.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Furthermore, there are additional simulation parameters with default values, summarized as follows:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"SimPara{F}\n├ trunc::Int\n├ n_data::Int\n├ n_ic::Int\n├ n_spinup::Int = 9\n├ t_step::Float32 = 1.0\n├ initial_cond::F = nothing\n└ id_key::String = \"\"","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"For example, a custom initial condition can be defined, or the time step can be adjusted.","category":"page"},{"location":"running_SWE/#Generating-Raw-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Generating Raw Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"With the simulation parameters defined, raw data can be generated directly from SpeedyWeather.jl:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"generate_raw_data(sim_para; overwrite=true)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This command creates a folder with one subdirectory per initial condition and stores the corresponding raw simulation output. If raw data with the same simulation parameters already exist and overwrite = false, data generation is aborted.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Generating raw data can be slow and memory-intensive (few gigabytes), since not only vorticity but also other prognostic variables (output of diagnostic variables is disabled) are written to disk. It should therefore be used sparingly, ideally only when new datasets are absolutely required! Instead, it is strongly recommended to use SimData objects (few megabytes) as often as possible. Furthermore, problems may arise if one attempts to delete the raw data within the same session in which they were generated.","category":"page"},{"location":"running_SWE/#Structured-Simulation-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Structured Simulation Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"In order to make use of raw data, it must be loaded into a SimData object, which is handled by a convenience constructor:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_data = SimData(sim_para)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The resulting tensor has dimensions textdata in mathbbR^(2 cdot n_textcoeff) times n_textdata times n_textic where real and imaginary parts of the spectral coefficients are stacked along the first axis. This format is optimized for efficient slicing over time and initial conditions, and serves as the basis for all later steps. It also consumes significantly less memory than the previous raw data and can be easily handled using the methods from Saving/Loading Data.","category":"page"},{"location":"running_SWE/#Preparing-Formatted-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Preparing Formatted Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"For machine learning, we need to turn the discrete time series into input–target pairs. The FormattedData constructor automates this process by pairing consecutive timesteps:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(x y) = bigl( mathrmvor(t)  mathrmvor(t + Delta t) bigr)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Then it splits the dataset into training, validation, and test sets. By default, the split is 70 % training, 15 % validation, and 15 % test:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"fd = FormattedData(sim_data)    # results in splits=(train=0.7, valid=0.15, test=0.15)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"However, arbitrary alternative splits can also be used. The convenience constructor internally handles non-unique splits by normalization:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"fd = FormattedData(sim_data,  splits=(train=100, valid=50, test=50))    # results in splits=(train=0.5, valid=0.25, test=0.25)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Since the targets are shifted forward in time, the total number of datapairs available is (n_data − 1) * n_ic.","category":"page"},{"location":"running_SWE/#Training","page":"Running SpeedyWeatherEmulator.jl","title":"Training","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Once the data pipeline is established, we can train a neural network to emulate the barotropic SpeedyWeather.jl model.   This involves defining an architecture, normalizing the data, building an emulator, training it on input–output pairs, and finally comparing predictions against reference data.","category":"page"},{"location":"running_SWE/#Neural-Network-Architecture","page":"Running SpeedyWeatherEmulator.jl","title":"Neural Network Architecture","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The emulator uses a simple feed-forward neural network with ReLU activations.   The architecture is described by a NeuralNetwork object, which specifies the input/output dimension, the hidden layer dimension (width), and the number of hidden layers (depth).","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"nn = NeuralNetwork(io_dim=54, hidden_dim=128, n_hidden=2)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This compact container makes it easy to experiment with different model sizes without touching the actual Flux code. ","category":"page"},{"location":"running_SWE/#Normalizsation-by-Z-Score","page":"Running SpeedyWeatherEmulator.jl","title":"Normalizsation by Z-Score","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Since the spectral coefficients have different orders of magnitude, each of them are seperately normalized before training using a Z-score transformation:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"z_i = fracx_i - mu_isigma_i","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"where mu_i is the mean and sigma_i the standard deviation of the ith spectral coefficient in the training set.  This is achieved with a ZscorePara struct, which stores the mean and standard deviation of the training set. Normalization is always based only on the training data to avoid information leakage. The emulator applies this transformation automatically when called.","category":"page"},{"location":"running_SWE/#The-Emulator-Wrapper","page":"Running SpeedyWeatherEmulator.jl","title":"The Emulator Wrapper","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The Emulator struct ","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Emulator{F, A<:AbstractVector{Float32}}\n├ sim_para::SimPara{F}\n├ chain::Flux.Chain\n└ zscore_para::ZscorePara{A}","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"bundles three pieces of information:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"the simulation parameters of the dataset,\nthe neural network chain built from Flux,\nthe Z-score normalization parameters.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This design keeps the metadata and the trained model tightly coupled.  For convenience, an emulator can be used like a function:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"y_pred = em(x)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"where x is a spectral coefficient tensor at time t and the output is the emulator prediction at t + t_step. The first dimension of x must equal the input/output dimension of the NeuralNetwork of em(). ","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Furthermore, Emulator automatically handles moving data to the GPU (if available) and back to the CPU.","category":"page"},{"location":"running_SWE/#Logging-Training-Progress","page":"Running SpeedyWeatherEmulator.jl","title":"Logging Training Progress","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"During training, losses are automatically collected in a Losses object. It stores the mean-squared errors for each batch of the training and validation sets, and also the time used for training (training_time) in seconds.  This makes it straightforward to plot learning curves and diagnose overfitting.","category":"page"},{"location":"running_SWE/#Training-the-Emulator","page":"Running SpeedyWeatherEmulator.jl","title":"Training the Emulator","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The central routine is train_emulator, which orchestrates the entire process:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Compute Z-score parameters from the training set.\nBuild an Emulator according to the chosen architecture.\nNormalize training and validation data.\nTrain with a Adam optimizer, starting with a given learning rate that halves every 30 epochs.\nRecord training and validation losses batch-by-batch.\nReinitializes the Losses object with the needed training time\nEvaluate the trained emulator on the test set.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"At the end, train_emulator prints rel. error statistics of the test set to STDOUT:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"--------------------------------------\nMean relative error: 13.041 %\nMax relative error:  62.957 %\n--------------------------------------","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"and returns both the trained emulator and its recorded loss history with training time.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"A typical training run looks like this:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"em, losses = train_emulator(nn, fd; batchsize=64, n_epochs=100, η0=0.0005)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Training times should be treated with caution. In order to compare the training times of different hyperparameters, a warm-up training must first be performed, since the initial training always takes longer.","category":"page"},{"location":"running_SWE/#Evaluating-Accurarcy","page":"Running SpeedyWeatherEmulator.jl","title":"Evaluating Accurarcy","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"To quantify performance, the function compare_emulator applies the trained model to unseen test inputs and compares the predictions against SpeedyWeather.jl reference outputs. It optionally reports mean and maximum relative errors in percent, and can optionally display the error of each spectral coefficient separately. The function also returns the overall average error, which is useful for automated evaluation.  compare_emulator is also used in train_emulator on the test set.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"compare_emulator(em; \n    x_test=fd.data_pairs.x_test,\n    y_test=fd.data_pairs.y_test,\n    all_coeff=true,\n    output=true)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"compare_emulator can also be used to compare multiple emulator steps (rollouts) by specifying the argument n_it:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"compare_emulator(em; \n    x_test=fd.data_pairs.x_test,\n    y_test=fd.data_pairs.y_test,\n    n_it = 3)   # corresponds to the comp. of em(em(em()))","category":"page"},{"location":"running_SWE/#Saving/Loading-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Saving/Loading Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Training an emulator often requires repeating experiments with different network architectures or datasets.   To make results reproducible and avoid re-running costly simulations, SpeedyWeatherEmulator.jl provides simple functions for saving and reloading data containers using JLD2.","category":"page"},{"location":"running_SWE/#Unified-File-Paths","page":"Running SpeedyWeatherEmulator.jl","title":"Unified File Paths","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"All saved objects — whether SimData, Emulator, or Losses — are uniquely identified by their simulation parameters (SimPara). The helper functions data_path and delete_data ensure that every dataset receives a consistent folder or file name:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Raw data are stored in dedicated folders with one subfolder per run.  \nAll other types (SimData, Emulator, Losses) are saved as single .jld2 files.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The file name includes truncation trunc, number of data points n_data, number of initial conditions n_ic, and a optional key id_key, e.g.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"data/sim_data/sim_data_T5_ndata50_IC200_ID_demo.jld2","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"In general, it is recommended not to rely solely on the identifiers trunc, n_data, and n_ic, but to always provide an additional id_key as well!","category":"page"},{"location":"running_SWE/#Saving-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Saving Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Any supported container (SimData, Emulator or Losses) can be saved with a single call:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"save_data(sim_data)\nsave_data(em; overwrite=true)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"In the second case existing data will be overwritten. By default, all data are stored in","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"SpeedyWeatherEmulator.jl/data\n├ emulator\n├ losses\n└ sim_data\n   └ sim_data_T5_ndata50_IC200_ID_demo.jld2","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"where sim_data_T5_ndata50_IC200_ID_demo.jld2 is an example of an stored SimData object.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"It is also possible to specify a custom path:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"save_data(sim_data, path = myPath)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"If data with the same simulation parameters already exist and overwrite = false (default), saving is aborted. No functions were defined for directly saving and loading raw data, since the storage structure is more complex than that of JLD2. However, this is not really necessary due to the existence of SimData.","category":"page"},{"location":"running_SWE/#Loading-Data","page":"Running SpeedyWeatherEmulator.jl","title":"Loading Data","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Previously saved objects can be reloaded at any time:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"sim_data_loaded = load_data(SimData, sim_para)\nem_loaded = load_data(Emulator, sim_para)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Here, the first argument specifies the object type to be loaded, and sim_para serves as the identifier of which one. A custom path can also be chosen again with path = myPath, from which the data will be loaded.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The function returns the object in its original type, making it seamless to continue training, evaluate a stored emulator, or plot old loss curves.","category":"page"},{"location":"running_SWE/#Visualization","page":"Running SpeedyWeatherEmulator.jl","title":"Visualization","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"After training an emulator, it is often useful to visualize its performance and inspect vorticity heatmaps.   SpeedyWeatherEmulator.jl provides a small set of plotting functions for these purposes.   The plotting routines are intentionally kept simple: apart from an optional title, almost no additional styling parameters are exposed, in order to keep the interface clear and focused.","category":"page"},{"location":"running_SWE/#Loss-Curves","page":"Running SpeedyWeatherEmulator.jl","title":"Loss Curves","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The function plot_losses visualizes the training history stored in a Losses object.   It displays:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"the raw training loss per batch (log–log scale),  \nthe mean training loss per epoch,  \nthe mean validation loss per epoch.  ","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"This makes it easy to diagnose whether the network is converging properly and whether overfitting occurs.","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"plot_losses(losses; title=\"Training History (T5)\")","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Loss Plot)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"The number of epochs is inferred automatically from the batch size and dataset split. The returned plot object can be further customized or saved using the standard Plots.jl interface.","category":"page"},{"location":"running_SWE/#Vorticity-Heatmaps","page":"Running SpeedyWeatherEmulator.jl","title":"Vorticity Heatmaps","text":"","category":"section"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"To inspect actual states of vorticity, the function plot_heatmap reconstructs a vorticity field from a spectral coefficient vector and shows it as a heatmap. This requires specifying the spectral truncation to interpret the coefficient layout correctly. With the argument range = (a, b) the color range of the heatmap can be adjusted:","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"vec = rand(Float32, 54)     # random coeffs for trunc=5\nplot_heatmap(vec; trunc=5, title=\"Random Vorticity Field\", range=(-2.5,+2.5))","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"(Image: Heatmap Plot)","category":"page"},{"location":"running_SWE/","page":"Running SpeedyWeatherEmulator.jl","title":"Running SpeedyWeatherEmulator.jl","text":"Internally, the coefficients are converted into a lower-triangular matrix and then transformed into a physical-space grid. The resulting heatmap provides an intuitive view of the spatial vorticity pattern represented by the spectral state. ","category":"page"},{"location":"#SpeedyWeatherEmulator.jl","page":"Home","title":"SpeedyWeatherEmulator.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SpeedyWeatherEmulator.jl package provides a framework for generating, processing, and emulating spectral vorticity data from the barotropic model in SpeedyWeather.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It enables users to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"configure and run controlled weather simulations,\nstore and format spectral coefficients into training-ready datasets,\ntrain neural network emulators with normalization and logging, and\nevaluate emulator performance against SpeedyWeather baselines with error metrics and visualizations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed to streamline the workflow from simulation to machine learning emulation, making it easier to test neural network approaches for atmospheric dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a quick overview of applications of SpeedyWeatherEmulator.jl, there is a Project Report available in the package repository. It briefly introduces the necessity and background of emulators and explains and discusses the Examples featured in this documentation. It also contains the list of references.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are interested in specific parts of the code or other details, the package repository is linked here: SpeedyWeatherEmulator.jl Repository.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"running_SWE.md\", \"examples.md\", \"functions_index.md\"]\nDepth = 2","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/SieglStefan/SpeedyWeatherEmulator.jl\")","category":"page"}]
}
