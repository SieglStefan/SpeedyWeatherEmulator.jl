<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Running SpeedyWeatherEmulator.jl · SpeedyWeatherEmulator.jl</title><meta name="title" content="Running SpeedyWeatherEmulator.jl · SpeedyWeatherEmulator.jl"/><meta property="og:title" content="Running SpeedyWeatherEmulator.jl · SpeedyWeatherEmulator.jl"/><meta property="twitter:title" content="Running SpeedyWeatherEmulator.jl · SpeedyWeatherEmulator.jl"/><meta name="description" content="Documentation for SpeedyWeatherEmulator.jl."/><meta property="og:description" content="Documentation for SpeedyWeatherEmulator.jl."/><meta property="twitter:description" content="Documentation for SpeedyWeatherEmulator.jl."/><meta property="og:url" content="https://SieglStefan.github.io/SpeedyWeatherEmulator.jl/running_SWE/"/><meta property="twitter:url" content="https://SieglStefan.github.io/SpeedyWeatherEmulator.jl/running_SWE/"/><link rel="canonical" href="https://SieglStefan.github.io/SpeedyWeatherEmulator.jl/running_SWE/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpeedyWeatherEmulator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Running SpeedyWeatherEmulator.jl</a><ul class="internal"><li><a class="tocitem" href="#Basic-Workflow"><span>Basic Workflow</span></a></li><li><a class="tocitem" href="#Generating-and-Formatting-Data"><span>Generating and Formatting Data</span></a></li><li><a class="tocitem" href="#Training"><span>Training</span></a></li><li><a class="tocitem" href="#Saving/Loading-Data"><span>Saving/Loading Data</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../functions_index/">Functions &amp; Types index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Running SpeedyWeatherEmulator.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Running SpeedyWeatherEmulator.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SieglStefan/SpeedyWeatherEmulator.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SieglStefan/SpeedyWeatherEmulator.jl/blob/main/docs/src/running_SWE.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Running-SpeedyWeatherEmulator.jl"><a class="docs-heading-anchor" href="#Running-SpeedyWeatherEmulator.jl">Running SpeedyWeatherEmulator.jl</a><a id="Running-SpeedyWeatherEmulator.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Running-SpeedyWeatherEmulator.jl" title="Permalink"></a></h1><p>This section introduces the core functionality of the package. After a short review of the basic workflow it provides a step-by-step overview of how to generate simulation data, format it for training, build and train an emulator, saving/loading data, and evaluate its performance.</p><p>For the plots in this chapter, a separate, slightly modified script was used. If you are particularly interested in this details, you can find the exact code used for plot creation in the repository folder <a href="https://github.com/SieglStefan/SpeedyWeatherEmulator.jl/tree/main/plot_utils/docs_plots_running_SWE"><code>plot_utils/docs_plots_running_SWE</code></a>.</p><h2 id="Basic-Workflow"><a class="docs-heading-anchor" href="#Basic-Workflow">Basic Workflow</a><a id="Basic-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Workflow" title="Permalink"></a></h2><p>This brief introduction to the workflow is meant to illustrate how the different steps, functions, and data types of the package interact. I have deliberately omitted details such as additional functions, parameters, or default values. These can be found in the sections below, seen in action in the examples or looked up in the source code.</p><p>Every workflow in SpeedyWeatherEmulator.jl begins by defining the simulation parameters in a <code>SimPara</code> object. These parameters control the spectral truncation, the number of datapoints to be stored per i.c., the number of independent initial conditions and more:</p><pre><code class="language-julia hljs">sim_para = SimPara(trunc=5, n_data=24, n_ic=800, id_key=&quot;_basic_workflow&quot;)</code></pre><p>With these parameters defined, raw vorticity data is generated using SpeedyWeather.jl and stored on disk.</p><pre><code class="language-julia hljs">generate_raw_data(sim_para)</code></pre><p>The raw files are then loaded into a <code>SimData</code> container, which provides a consistent array layout. From this, formatted datasets are built, splitting the vorticity time series into train/validation/test pairs.</p><pre><code class="language-julia hljs">sim_data = SimData(sim_para)
fd = FormattedData(sim_data)</code></pre><p>Next, a neural network architecture is defined and trained on the formatted data. This produces both an <code>Emulator</code> (the trained model) and a <code>Losses</code> object that tracks training progress.</p><pre><code class="language-julia hljs">nn = NeuralNetwork()
em, losses = train_emulator(nn, fd)</code></pre><p>After the training, the mean relative error and max relative error for one step are printed to STDOUT:</p><pre><code class="language-text hljs">--------------------------------------
Mean relative error: 3.528 %
Max relative error:  6.673 %
--------------------------------------</code></pre><p>The recorded losses can then be visualized:</p><pre><code class="language-julia hljs">plot_losses(losses)</code></pre><p><img src="../assets/running_SWE/losses_BWF.png" alt="Loss curves"/></p><p>Finally, we can visually compare emulator predictions with SpeedyWeather.jl outputs. Here we select one vorticity state (<code>vor0</code>), its SpeedyWeather forecast (<code>vorSW</code>), and the emulator’s prediction (<code>vorEM</code>) after six steps. This corresponds to a six hour forecast:</p><pre><code class="language-julia hljs">vor0 = fd.data_pairs.x_test[:,10,1]
vor_sw = fd.data_pairs.y_test[:,10+6,1]

# Calculate emulator vorticity
vor_em = vor0
for _ in 1:6
    global vor_em = em(vor_em)
end</code></pre><p>Each of them can be visualized as a heatmap,</p><pre><code class="language-julia hljs">colorrange = (-2.5e-5, +2.5e-5)
plot_heatmap(vor0, trunc=5, title=&quot;Initial Vorticity vor0&quot;, range=colorrange)
plot_heatmap(vor_sw, trunc=5, title=&quot;Target Vorticity vor_sw&quot;, range=colorrange)
plot_heatmap(vor_em, trunc=5, title=&quot;Emulated Vorticity vor_em&quot;, range=colorrange)</code></pre><p>resulting in:</p><p><img src="../assets/running_SWE/vor0_BWF.png" alt="Initial Vorticity vor0"/></p><p><img src="../assets/running_SWE/vor_sw_BWF.png" alt="Taget Vorticity vor_sw"/></p><p><img src="../assets/running_SWE/vor_em_BWF.png" alt="Emulated Vorticity vor_em"/></p><p>The difference between the initial vorticity and the final vorticity is small, but it can be seen that the emulator already approximates the target SpeedyWeather.jl data reasonably well.</p><h2 id="Generating-and-Formatting-Data"><a class="docs-heading-anchor" href="#Generating-and-Formatting-Data">Generating and Formatting Data</a><a id="Generating-and-Formatting-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-and-Formatting-Data" title="Permalink"></a></h2><p>Before training a emulator, we need to generate and structure data.   This process has three steps: defining the simulation parameters, running SpeedyWeather.jl to create raw data, and finally preparing formatted datasets for machine learning.</p><h3 id="Simulation-Parameters"><a class="docs-heading-anchor" href="#Simulation-Parameters">Simulation Parameters</a><a id="Simulation-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Parameters" title="Permalink"></a></h3><p>Every workflow begins by specifying the simulation setup in a <code>SimPara</code> object.   This struct collects the essential parameters of a barotropic SpeedyWeather.jl simulation:</p><ul><li>the spectral truncation (<code>trunc</code>, e.g. T5),  </li><li>the number of stored timesteps after spin-up (<code>n_data</code>),  </li><li>the number of independent initial conditions (<code>n_ic</code>),  </li><li>and additional metadata such as spin-up length, timestep size, or a unique <code>id_key</code>.</li></ul><p>Together, these parameters determine both the structure of the generated data. For example:</p><pre><code class="language-julia hljs">sim_para = SimPara(trunc=5, n_data=50, n_ic=200, id_key=&quot;_test1&quot;)</code></pre><p>It should be emphasized that only the fields used in the example above are responsible for saving and loading data. In general, it is recommended not to rely solely on the identifiers <code>trunc</code>, <code>n_data</code>, and <code>n_ic</code>, but to always provide an additional <code>id_key</code> as well! See <a href="#savingloading-data">Saving/Loading Data</a> for details.</p><p>Furthermore, there are additional simulation parameters with default values, summarized as follows:</p><pre><code class="language-julia hljs">SimPara{F}
├ trunc::Int
├ n_data::Int
├ n_ic::Int
├ n_spinup::Int = 9
├ t_step::Float32 = 1.0
├ initial_cond::F = nothing
└ id_key::String = &quot;&quot;</code></pre><p>For example, a custom initial condition can be defined, or the time step can be adjusted.</p><h3 id="Generating-Raw-Data"><a class="docs-heading-anchor" href="#Generating-Raw-Data">Generating Raw Data</a><a id="Generating-Raw-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Raw-Data" title="Permalink"></a></h3><p>With the simulation parameters defined, raw data can be generated directly from SpeedyWeather.jl:</p><pre><code class="language-julia hljs">generate_raw_data(sim_para; overwrite=true)</code></pre><p>This command creates a folder with one subdirectory per initial condition and stores the corresponding raw simulation output. If raw data with the same simulation parameters already exist and <code>overwrite = false</code>, data generation is aborted.</p><p>Generating raw data can be slow and memory-intensive (few gigabytes), since not only vorticity but also other prognostic variables (output of diagnostic variables is disabled) are written to disk. It should therefore be used sparingly, ideally only when new datasets are absolutely required! Instead, it is strongly recommended to use <code>SimData</code> objects (few megabytes) as often as possible. Furthermore, problems may arise if one attempts to delete the raw data within the same session in which they were generated.</p><h3 id="Structured-Simulation-Data"><a class="docs-heading-anchor" href="#Structured-Simulation-Data">Structured Simulation Data</a><a id="Structured-Simulation-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-Simulation-Data" title="Permalink"></a></h3><p>In order to make use of raw data, it must be loaded into a <code>SimData</code> object, which is handled by a convenience constructor:</p><pre><code class="language-julia hljs">sim_data = SimData(sim_para)</code></pre><p>The resulting tensor has dimensions <span>$\text{data} \in \mathbb{R}^{(2 \cdot n_\text{coeff}) \times n_\text{data} \times n_\text{ic}}$</span> where real and imaginary parts of the spectral coefficients are stacked along the first axis. This format is optimized for efficient slicing over time and initial conditions, and serves as the basis for all later steps. It also consumes significantly less memory than the previous raw data and can be easily handled using the methods from <a href="#savingloading-data">Saving/Loading Data</a>.</p><h3 id="Preparing-Formatted-Data"><a class="docs-heading-anchor" href="#Preparing-Formatted-Data">Preparing Formatted Data</a><a id="Preparing-Formatted-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-Formatted-Data" title="Permalink"></a></h3><p>For machine learning, we need to turn the discrete time series into input–target pairs. The <code>FormattedData</code> constructor automates this process by pairing consecutive timesteps:</p><p class="math-container">\[(x, y) = \bigl( \mathrm{vor}(t), \, \mathrm{vor}(t + \Delta t) \bigr)\]</p><p>Then it splits the dataset into training, validation, and test sets. By default, the split is 70 % training, 15 % validation, and 15 % test:</p><pre><code class="language-julia hljs">fd = FormattedData(sim_data)    # results in splits=(train=0.7, valid=0.15, test=0.15)</code></pre><p>However, arbitrary alternative splits can also be used. The convenience constructor internally handles non-unique splits by normalization:</p><pre><code class="language-julia hljs">fd = FormattedData(sim_data,  splits=(train=100, valid=50, test=50))    # results in splits=(train=0.5, valid=0.25, test=0.25)</code></pre><p>Since the targets are shifted forward in time, the total number of datapairs available is <code>(n_data − 1) * n_ic</code>.</p><h2 id="Training"><a class="docs-heading-anchor" href="#Training">Training</a><a id="Training-1"></a><a class="docs-heading-anchor-permalink" href="#Training" title="Permalink"></a></h2><p>Once the data pipeline is established, we can train a neural network to emulate the barotropic SpeedyWeather.jl model.   This involves defining an architecture, normalizing the data, building an emulator, training it on input–output pairs, and finally comparing predictions against reference data.</p><h3 id="Neural-Network-Architecture"><a class="docs-heading-anchor" href="#Neural-Network-Architecture">Neural Network Architecture</a><a id="Neural-Network-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-Network-Architecture" title="Permalink"></a></h3><p>The emulator uses a simple feed-forward neural network with ReLU activations.   The architecture is described by a <code>NeuralNetwork</code> object, which specifies the input/output dimension, the hidden layer dimension (width), and the number of hidden layers (depth).</p><pre><code class="language-julia hljs">nn = NeuralNetwork(io_dim=54, hidden_dim=128, n_hidden=2)</code></pre><p>This compact container makes it easy to experiment with different model sizes without touching the actual Flux code. </p><h3 id="Normalizsation-by-Z-Score"><a class="docs-heading-anchor" href="#Normalizsation-by-Z-Score">Normalizsation by Z-Score</a><a id="Normalizsation-by-Z-Score-1"></a><a class="docs-heading-anchor-permalink" href="#Normalizsation-by-Z-Score" title="Permalink"></a></h3><p>Since the spectral coefficients have different orders of magnitude, each of them are seperately normalized before training using a Z-score transformation:</p><p class="math-container">\[z_i = \frac{x_i - \mu_i}{\sigma_i},\]</p><p>where <span>$\mu_i$</span> is the mean and <span>$\sigma_i$</span> the standard deviation of the ith spectral coefficient in the training set.  This is achieved with a <code>ZscorePara</code> struct, which stores the mean and standard deviation of the training set. Normalization is always based only on the training data to avoid information leakage. The emulator applies this transformation automatically when called.</p><h3 id="The-Emulator-Wrapper"><a class="docs-heading-anchor" href="#The-Emulator-Wrapper">The Emulator Wrapper</a><a id="The-Emulator-Wrapper-1"></a><a class="docs-heading-anchor-permalink" href="#The-Emulator-Wrapper" title="Permalink"></a></h3><p>The Emulator struct </p><pre><code class="language-julia hljs">Emulator{F, A&lt;:AbstractVector{Float32}}
├ sim_para::SimPara{F}
├ chain::Flux.Chain
└ zscore_para::ZscorePara{A}</code></pre><p>bundles three pieces of information:</p><ul><li>the simulation parameters of the dataset,</li><li>the neural network chain built from Flux,</li><li>the Z-score normalization parameters.</li></ul><p>This design keeps the metadata and the trained model tightly coupled.  For convenience, an emulator can be used like a function:</p><pre><code class="language-julia hljs">y_pred = em(x)</code></pre><p>where <code>x</code> is a spectral coefficient tensor at time <code>t</code> and the output is the emulator prediction at <code>t + t_step</code>. The first dimension of <code>x</code> must equal the input/output dimension of the <code>NeuralNetwork</code> of <code>em()</code>. </p><p>Furthermore, <code>Emulator</code> automatically handles moving data to the GPU (if available) and back to the CPU.</p><h3 id="Logging-Training-Progress"><a class="docs-heading-anchor" href="#Logging-Training-Progress">Logging Training Progress</a><a id="Logging-Training-Progress-1"></a><a class="docs-heading-anchor-permalink" href="#Logging-Training-Progress" title="Permalink"></a></h3><p>During training, losses are automatically collected in a <code>Losses</code> object. It stores the mean-squared errors for each batch of the training and validation sets, and also the time used for training (<code>training_time</code>) in seconds.  This makes it straightforward to plot learning curves and diagnose overfitting.</p><h3 id="Training-the-Emulator"><a class="docs-heading-anchor" href="#Training-the-Emulator">Training the Emulator</a><a id="Training-the-Emulator-1"></a><a class="docs-heading-anchor-permalink" href="#Training-the-Emulator" title="Permalink"></a></h3><p>The central routine is <code>train_emulator</code>, which orchestrates the entire process:</p><ol><li>Compute Z-score parameters from the training set.</li><li>Build an <code>Emulator</code> according to the chosen architecture.</li><li>Normalize training and validation data.</li><li>Train with a Adam optimizer, starting with a given learning rate that halves every 30 epochs.</li><li>Record training and validation losses batch-by-batch.</li><li>Reinitializes the <code>Losses</code> object with the needed training time</li><li>Evaluate the trained emulator on the test set.</li></ol><p>At the end, <code>train_emulator</code> prints rel. error statistics of the test set to <code>STDOUT</code>:</p><pre><code class="language-text hljs">--------------------------------------
Mean relative error: 13.041 %
Max relative error:  62.957 %
--------------------------------------</code></pre><p>and returns both the trained emulator and its recorded loss history with training time.</p><p>A typical training run looks like this:</p><pre><code class="language-julia hljs">em, losses = train_emulator(nn, fd; batchsize=64, n_epochs=100, η0=0.0005)</code></pre><p>Training times should be treated with caution. In order to compare the training times of different hyperparameters, a warm-up training must first be performed, since the initial training always takes longer.</p><h3 id="Evaluating-Accurarcy"><a class="docs-heading-anchor" href="#Evaluating-Accurarcy">Evaluating Accurarcy</a><a id="Evaluating-Accurarcy-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-Accurarcy" title="Permalink"></a></h3><p>To quantify performance, the function <code>compare_emulator</code> applies the trained model to unseen test inputs and compares the predictions against SpeedyWeather.jl reference outputs. It optionally reports mean and maximum relative errors in percent, and can optionally display the error of each spectral coefficient separately. The function also returns the overall average error, which is useful for automated evaluation.  <code>compare_emulator</code> is also used in <code>train_emulator</code> on the test set.</p><pre><code class="language-julia hljs">compare_emulator(em; 
    x_test=fd.data_pairs.x_test,
    y_test=fd.data_pairs.y_test,
    all_coeff=true,
    output=true)</code></pre><p><code>compare_emulator</code> can also be used to compare multiple emulator steps (rollouts) by specifying the argument <code>n_it</code>:</p><pre><code class="language-julia hljs">compare_emulator(em; 
    x_test=fd.data_pairs.x_test,
    y_test=fd.data_pairs.y_test,
    n_it = 3)   # corresponds to the comp. of em(em(em()))</code></pre><h2 id="Saving/Loading-Data"><a class="docs-heading-anchor" href="#Saving/Loading-Data">Saving/Loading Data</a><a id="Saving/Loading-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Saving/Loading-Data" title="Permalink"></a></h2><p>Training an emulator often requires repeating experiments with different network architectures or datasets.   To make results reproducible and avoid re-running costly simulations, SpeedyWeatherEmulator.jl provides simple functions for saving and reloading data containers using JLD2.</p><h3 id="Unified-File-Paths"><a class="docs-heading-anchor" href="#Unified-File-Paths">Unified File Paths</a><a id="Unified-File-Paths-1"></a><a class="docs-heading-anchor-permalink" href="#Unified-File-Paths" title="Permalink"></a></h3><p>All saved objects — whether <code>SimData</code>, <code>Emulator</code>, or <code>Losses</code> — are uniquely identified by their simulation parameters (<code>SimPara</code>). The helper functions <code>data_path</code> and <code>delete_data</code> ensure that every dataset receives a consistent folder or file name:</p><ul><li>Raw data are stored in dedicated folders with one subfolder per run.  </li><li>All other types (<code>SimData</code>, <code>Emulator</code>, <code>Losses</code>) are saved as single <code>.jld2</code> files.</li></ul><p>The file name includes truncation <code>trunc</code>, number of data points <code>n_data</code>, number of initial conditions <code>n_ic</code>, and a optional key <code>id_key</code>, e.g.</p><pre><code class="language-text hljs">data/sim_data/sim_data_T5_ndata50_IC200_ID_demo.jld2</code></pre><p>In general, it is recommended not to rely solely on the identifiers <code>trunc</code>, <code>n_data</code>, and <code>n_ic</code>, but to always provide an additional <code>id_key</code> as well!</p><h3 id="Saving-Data"><a class="docs-heading-anchor" href="#Saving-Data">Saving Data</a><a id="Saving-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-Data" title="Permalink"></a></h3><p>Any supported container (<code>SimData</code>, <code>Emulator</code> or <code>Losses</code>) can be saved with a single call:</p><pre><code class="language-julia hljs">save_data(sim_data)
save_data(em; overwrite=true)</code></pre><p>In the second case existing data will be overwritten. By default, all data are stored in</p><pre><code class="language-julia hljs">SpeedyWeatherEmulator.jl/data
├ emulator
├ losses
└ sim_data
   └ sim_data_T5_ndata50_IC200_ID_demo.jld2</code></pre><p>where <code>sim_data_T5_ndata50_IC200_ID_demo.jld2</code> is an example of an stored <code>SimData</code> object.</p><p>It is also possible to specify a custom path:</p><pre><code class="language-julia hljs">save_data(sim_data, path = myPath)</code></pre><p>If data with the same simulation parameters already exist and <code>overwrite = false</code> (default), saving is aborted. No functions were defined for directly saving and loading raw data, since the storage structure is more complex than that of JLD2. However, this is not really necessary due to the existence of <code>SimData</code>.</p><h3 id="Loading-Data"><a class="docs-heading-anchor" href="#Loading-Data">Loading Data</a><a id="Loading-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-Data" title="Permalink"></a></h3><p>Previously saved objects can be reloaded at any time:</p><pre><code class="language-julia hljs">sim_data_loaded = load_data(SimData, sim_para)
em_loaded = load_data(Emulator, sim_para)</code></pre><p>Here, the first argument specifies the object type to be loaded, and sim_para serves as the identifier of which one. A custom path can also be chosen again with <code>path = myPath</code>, from which the data will be loaded.</p><p>The function returns the object in its original type, making it seamless to continue training, evaluate a stored emulator, or plot old loss curves.</p><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>After training an emulator, it is often useful to visualize its performance and inspect vorticity heatmaps.   SpeedyWeatherEmulator.jl provides a small set of plotting functions for these purposes.   The plotting routines are intentionally kept simple: apart from an optional <code>title</code>, almost no additional styling parameters are exposed, in order to keep the interface clear and focused.</p><h3 id="Loss-Curves"><a class="docs-heading-anchor" href="#Loss-Curves">Loss Curves</a><a id="Loss-Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-Curves" title="Permalink"></a></h3><p>The function <code>plot_losses</code> visualizes the training history stored in a <code>Losses</code> object.   It displays:</p><ol><li>the raw training loss per batch (log–log scale),  </li><li>the mean training loss per epoch,  </li><li>the mean validation loss per epoch.  </li></ol><p>This makes it easy to diagnose whether the network is converging properly and whether overfitting occurs.</p><pre><code class="language-julia hljs">plot_losses(losses; title=&quot;Training History (T5)&quot;)</code></pre><p><img src="../assets/running_SWE/losses.png" alt="Loss Plot"/></p><p>The number of epochs is inferred automatically from the batch size and dataset split. The returned plot object can be further customized or saved using the standard Plots.jl interface.</p><h3 id="Vorticity-Heatmaps"><a class="docs-heading-anchor" href="#Vorticity-Heatmaps">Vorticity Heatmaps</a><a id="Vorticity-Heatmaps-1"></a><a class="docs-heading-anchor-permalink" href="#Vorticity-Heatmaps" title="Permalink"></a></h3><p>To inspect actual states of vorticity, the function <code>plot_heatmap</code> reconstructs a vorticity field from a spectral coefficient vector and shows it as a heatmap. This requires specifying the spectral truncation to interpret the coefficient layout correctly. With the argument <code>range = (a, b)</code> the color range of the heatmap can be adjusted:</p><pre><code class="language-julia hljs">vec = rand(Float32, 54)     # random coeffs for trunc=5
plot_heatmap(vec; trunc=5, title=&quot;Random Vorticity Field&quot;, range=(-2.5,+2.5))</code></pre><p><img src="../assets/running_SWE/heatmap.png" alt="Heatmap Plot"/></p><p>Internally, the coefficients are converted into a lower-triangular matrix and then transformed into a physical-space grid. The resulting heatmap provides an intuitive view of the spatial vorticity pattern represented by the spectral state. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 9 September 2025 19:19">Tuesday 9 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
